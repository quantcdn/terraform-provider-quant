// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_rule_proxy

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func RuleProxyResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"action": schema.StringAttribute{
				Computed: true,
			},
			"action_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"auth_pass": schema.StringAttribute{
						Computed: true,
					},
					"auth_user": schema.StringAttribute{
						Computed: true,
					},
					"cache_lifetime": schema.Int64Attribute{
						Computed: true,
						Default:  int64default.StaticInt64(0),
					},
					"disable_ssl_verify": schema.BoolAttribute{
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
					"failover_lifetime": schema.StringAttribute{
						Computed: true,
					},
					"failover_mode": schema.BoolAttribute{
						Computed: true,
					},
					"failover_origin_status_codes": schema.ListAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"failover_origin_ttfb": schema.StringAttribute{
						Computed: true,
					},
					"host": schema.StringAttribute{
						Computed: true,
					},
					"inject_headers": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"notify": schema.StringAttribute{
						Computed: true,
					},
					"notify_config": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"origin_status_codes": schema.ListAttribute{
								ElementType: types.StringType,
								Computed:    true,
							},
							"period": schema.StringAttribute{
								Computed: true,
								Default:  stringdefault.StaticString("60"),
							},
							"slack_webhook": schema.StringAttribute{
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
						},
						CustomType: NotifyConfigType{
							ObjectType: types.ObjectType{
								AttrTypes: NotifyConfigValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"notify_email": schema.StringAttribute{
						Computed: true,
					},
					"only_proxy_404": schema.BoolAttribute{
						Computed: true,
					},
					"origin_timeout": schema.StringAttribute{
						Computed: true,
					},
					"proxy_alert_enabled": schema.BoolAttribute{
						Computed: true,
					},
					"proxy_strip_headers": schema.ListAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"proxy_strip_request_headers": schema.ListAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"to": schema.StringAttribute{
						Computed: true,
					},
					"waf_config": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_ip": schema.ListAttribute{
								ElementType: types.StringType,
								Computed:    true,
							},
							"allow_rules": schema.ListAttribute{
								ElementType: types.StringType,
								Computed:    true,
							},
							"block_ip": schema.ListAttribute{
								ElementType: types.StringType,
								Computed:    true,
							},
							"block_lists": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"ai": schema.BoolAttribute{
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
									"ip": schema.BoolAttribute{
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
									"referer": schema.BoolAttribute{
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
									"user_agent": schema.BoolAttribute{
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
								},
								CustomType: BlockListsType{
									ObjectType: types.ObjectType{
										AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"block_referer": schema.ListAttribute{
								ElementType: types.StringType,
								Computed:    true,
							},
							"block_ua": schema.ListAttribute{
								ElementType: types.StringType,
								Computed:    true,
							},
							"httpbl": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"api_key": schema.StringAttribute{
										Computed: true,
									},
									"block_harvester": schema.BoolAttribute{
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
									"block_search_engine": schema.BoolAttribute{
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
									"block_spam": schema.BoolAttribute{
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
									"block_suspicious": schema.BoolAttribute{
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
									"httpbl_enabled": schema.BoolAttribute{
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
								},
								CustomType: HttpblType{
									ObjectType: types.ObjectType{
										AttrTypes: HttpblValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"httpbl_enabled": schema.MapAttribute{
								ElementType: types.BoolType,
								Computed:    true,
							},
							"ip_ratelimit_cooldown": schema.Int64Attribute{
								Computed: true,
								Default:  int64default.StaticInt64(30),
							},
							"ip_ratelimit_mode": schema.StringAttribute{
								Computed: true,
								Default:  stringdefault.StaticString("disabled"),
							},
							"ip_ratelimit_rps": schema.Int64Attribute{
								Computed: true,
								Default:  int64default.StaticInt64(5),
							},
							"mode": schema.StringAttribute{
								Computed: true,
							},
							"notify_email": schema.ListAttribute{
								ElementType: types.StringType,
								Computed:    true,
							},
							"notify_slack": schema.StringAttribute{
								Computed: true,
							},
							"notify_slack_hits_rpm": schema.Int64Attribute{
								Computed: true,
							},
							"notify_slack_rpm": schema.Int64Attribute{
								Computed: true,
							},
							"paranoia_level": schema.Int64Attribute{
								Computed: true,
								Default:  int64default.StaticInt64(1),
							},
							"request_header_name": schema.StringAttribute{
								Computed: true,
							},
							"request_header_ratelimit_cooldown": schema.Int64Attribute{
								Computed: true,
								Default:  int64default.StaticInt64(30),
							},
							"request_header_ratelimit_mode": schema.StringAttribute{
								Computed: true,
								Default:  stringdefault.StaticString("disabled"),
							},
							"request_header_ratelimit_rps": schema.Int64Attribute{
								Computed: true,
								Default:  int64default.StaticInt64(5),
							},
							"thresholds": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"cooldown": schema.Int64Attribute{
											Computed: true,
										},
										"hits": schema.Int64Attribute{
											Computed: true,
										},
										"minutes": schema.Int64Attribute{
											Computed: true,
										},
										"mode": schema.StringAttribute{
											Computed: true,
											Default:  stringdefault.StaticString("disabled"),
										},
										"notify_slack": schema.StringAttribute{
											Computed: true,
										},
										"rps": schema.Int64Attribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed: true,
										},
										"value": schema.StringAttribute{
											Computed: true,
										},
									},
									CustomType: ThresholdsType{
										ObjectType: types.ObjectType{
											AttrTypes: ThresholdsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed: true,
							},
							"waf_ratelimit_cooldown": schema.Int64Attribute{
								Computed: true,
								Default:  int64default.StaticInt64(300),
							},
							"waf_ratelimit_hits": schema.Int64Attribute{
								Computed: true,
								Default:  int64default.StaticInt64(10),
							},
							"waf_ratelimit_mode": schema.StringAttribute{
								Computed: true,
								Default:  stringdefault.StaticString("disabled"),
							},
							"waf_ratelimit_rps": schema.Int64Attribute{
								Computed: true,
								Default:  int64default.StaticInt64(5),
							},
						},
						CustomType: WafConfigType{
							ObjectType: types.ObjectType{
								AttrTypes: WafConfigValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"waf_enabled": schema.BoolAttribute{
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
				},
				CustomType: ActionConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: ActionConfigValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"auth_pass": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"auth_user": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"cache_lifetime": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"cookie_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"country": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"country_is",
						"country_is_not",
					),
				},
			},
			"country_is": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"country_is_not": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"disable_ssl_verify": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"disabled": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(false),
			},
			"domain": schema.ListAttribute{
				ElementType: types.StringType,
				Required:    true,
			},
			"failover_lifetime": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Default:  stringdefault.StaticString("300"),
			},
			"failover_mode": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"failover_origin_status_codes": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"failover_origin_ttfb": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Default:  stringdefault.StaticString("2000"),
			},
			"host": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"inject_headers": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"ip": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"ip_is",
						"ip_is_not",
					),
				},
			},
			"ip_is": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"ip_is_not": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"method": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"method_is",
						"method_is_not",
					),
				},
			},
			"method_is": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"method_is_not": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"name": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"notify": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"none",
						"slack",
					),
				},
				Default: stringdefault.StaticString("none"),
			},
			"notify_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"origin_status_codes": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"period": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString("60"),
					},
					"slack_webhook": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
				},
				CustomType: NotifyConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: NotifyConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"only_proxy_404": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"only_with_cookie": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(false),
			},
			"organization": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"project": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"proxy_strip_headers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"proxy_strip_request_headers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"rule": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"to": schema.StringAttribute{
				Required: true,
			},
			"url": schema.ListAttribute{
				ElementType: types.StringType,
				Required:    true,
			},
			"uuid": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"waf_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allow_ip": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"allow_rules": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"block_ip": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"block_lists": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"ai": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"ip": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"referer": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"user_agent": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
						},
						CustomType: BlockListsType{
							ObjectType: types.ObjectType{
								AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"block_referer": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"block_ua": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"httpbl": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"api_key": schema.StringAttribute{
								Optional: true,
								Computed: true,
							},
							"block_harvester": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"block_search_engine": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"block_spam": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"block_suspicious": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"httpbl_enabled": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
						},
						CustomType: HttpblType{
							ObjectType: types.ObjectType{
								AttrTypes: HttpblValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"httpbl_enabled": schema.MapAttribute{
						ElementType: types.BoolType,
						Optional:    true,
						Computed:    true,
					},
					"ip_ratelimit_cooldown": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(30),
					},
					"ip_ratelimit_mode": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"disabled",
								"block",
								"report",
							),
						},
						Default: stringdefault.StaticString("disabled"),
					},
					"ip_ratelimit_rps": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(5),
					},
					"mode": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"block",
								"report",
							),
						},
					},
					"notify_email": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"notify_slack": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"notify_slack_hits_rpm": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"notify_slack_rpm": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"paranoia_level": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(1),
					},
					"request_header_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"request_header_ratelimit_cooldown": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(30),
					},
					"request_header_ratelimit_mode": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"disabled",
								"block",
								"report",
							),
						},
						Default: stringdefault.StaticString("disabled"),
					},
					"request_header_ratelimit_rps": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(5),
					},
					"thresholds": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"cooldown": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"hits": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"minutes": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"mode": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Default:  stringdefault.StaticString("disabled"),
								},
								"notify_slack": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"rps": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"type": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"value": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
							},
							CustomType: ThresholdsType{
								ObjectType: types.ObjectType{
									AttrTypes: ThresholdsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
					"waf_ratelimit_cooldown": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(300),
					},
					"waf_ratelimit_hits": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(10),
					},
					"waf_ratelimit_mode": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"disabled",
								"block",
								"report",
							),
						},
						Default: stringdefault.StaticString("disabled"),
					},
					"waf_ratelimit_rps": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(5),
					},
				},
				CustomType: WafConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: WafConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"waf_enabled": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(false),
			},
		},
	}
}

type RuleProxyModel struct {
	Action                    types.String      `tfsdk:"action"`
	ActionConfig              ActionConfigValue `tfsdk:"action_config"`
	AuthPass                  types.String      `tfsdk:"auth_pass"`
	AuthUser                  types.String      `tfsdk:"auth_user"`
	CacheLifetime             types.Int64       `tfsdk:"cache_lifetime"`
	CookieName                types.String      `tfsdk:"cookie_name"`
	Country                   types.String      `tfsdk:"country"`
	CountryIs                 types.List        `tfsdk:"country_is"`
	CountryIsNot              types.List        `tfsdk:"country_is_not"`
	DisableSslVerify          types.Bool        `tfsdk:"disable_ssl_verify"`
	Disabled                  types.Bool        `tfsdk:"disabled"`
	Domain                    types.List        `tfsdk:"domain"`
	FailoverLifetime          types.String      `tfsdk:"failover_lifetime"`
	FailoverMode              types.String      `tfsdk:"failover_mode"`
	FailoverOriginStatusCodes types.List        `tfsdk:"failover_origin_status_codes"`
	FailoverOriginTtfb        types.String      `tfsdk:"failover_origin_ttfb"`
	Host                      types.String      `tfsdk:"host"`
	InjectHeaders             types.Map         `tfsdk:"inject_headers"`
	Ip                        types.String      `tfsdk:"ip"`
	IpIs                      types.List        `tfsdk:"ip_is"`
	IpIsNot                   types.List        `tfsdk:"ip_is_not"`
	Method                    types.String      `tfsdk:"method"`
	MethodIs                  types.List        `tfsdk:"method_is"`
	MethodIsNot               types.List        `tfsdk:"method_is_not"`
	Name                      types.String      `tfsdk:"name"`
	Notify                    types.String      `tfsdk:"notify"`
	NotifyConfig              NotifyConfigValue `tfsdk:"notify_config"`
	OnlyProxy404              types.Bool        `tfsdk:"only_proxy_404"`
	OnlyWithCookie            types.Bool        `tfsdk:"only_with_cookie"`
	Organization              types.String      `tfsdk:"organization"`
	Project                   types.String      `tfsdk:"project"`
	ProxyStripHeaders         types.List        `tfsdk:"proxy_strip_headers"`
	ProxyStripRequestHeaders  types.List        `tfsdk:"proxy_strip_request_headers"`
	Rule                      types.String      `tfsdk:"rule"`
	To                        types.String      `tfsdk:"to"`
	Url                       types.List        `tfsdk:"url"`
	Uuid                      types.String      `tfsdk:"uuid"`
	WafConfig                 WafConfigValue    `tfsdk:"waf_config"`
	WafEnabled                types.Bool        `tfsdk:"waf_enabled"`
}

var _ basetypes.ObjectTypable = ActionConfigType{}

type ActionConfigType struct {
	basetypes.ObjectType
}

func (t ActionConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ActionConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionConfigType) String() string {
	return "ActionConfigType"
}

func (t ActionConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authPassAttribute, ok := attributes["auth_pass"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_pass is missing from object`)

		return nil, diags
	}

	authPassVal, ok := authPassAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_pass expected to be basetypes.StringValue, was: %T`, authPassAttribute))
	}

	authUserAttribute, ok := attributes["auth_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_user is missing from object`)

		return nil, diags
	}

	authUserVal, ok := authUserAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_user expected to be basetypes.StringValue, was: %T`, authUserAttribute))
	}

	cacheLifetimeAttribute, ok := attributes["cache_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cache_lifetime is missing from object`)

		return nil, diags
	}

	cacheLifetimeVal, ok := cacheLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cache_lifetime expected to be basetypes.Int64Value, was: %T`, cacheLifetimeAttribute))
	}

	disableSslVerifyAttribute, ok := attributes["disable_ssl_verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_ssl_verify is missing from object`)

		return nil, diags
	}

	disableSslVerifyVal, ok := disableSslVerifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_ssl_verify expected to be basetypes.BoolValue, was: %T`, disableSslVerifyAttribute))
	}

	failoverLifetimeAttribute, ok := attributes["failover_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_lifetime is missing from object`)

		return nil, diags
	}

	failoverLifetimeVal, ok := failoverLifetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_lifetime expected to be basetypes.StringValue, was: %T`, failoverLifetimeAttribute))
	}

	failoverModeAttribute, ok := attributes["failover_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_mode is missing from object`)

		return nil, diags
	}

	failoverModeVal, ok := failoverModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_mode expected to be basetypes.BoolValue, was: %T`, failoverModeAttribute))
	}

	failoverOriginStatusCodesAttribute, ok := attributes["failover_origin_status_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_origin_status_codes is missing from object`)

		return nil, diags
	}

	failoverOriginStatusCodesVal, ok := failoverOriginStatusCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_origin_status_codes expected to be basetypes.ListValue, was: %T`, failoverOriginStatusCodesAttribute))
	}

	failoverOriginTtfbAttribute, ok := attributes["failover_origin_ttfb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_origin_ttfb is missing from object`)

		return nil, diags
	}

	failoverOriginTtfbVal, ok := failoverOriginTtfbAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_origin_ttfb expected to be basetypes.StringValue, was: %T`, failoverOriginTtfbAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	injectHeadersAttribute, ok := attributes["inject_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inject_headers is missing from object`)

		return nil, diags
	}

	injectHeadersVal, ok := injectHeadersAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inject_headers expected to be basetypes.MapValue, was: %T`, injectHeadersAttribute))
	}

	notifyAttribute, ok := attributes["notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify is missing from object`)

		return nil, diags
	}

	notifyVal, ok := notifyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify expected to be basetypes.StringValue, was: %T`, notifyAttribute))
	}

	notifyConfigAttribute, ok := attributes["notify_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_config is missing from object`)

		return nil, diags
	}

	notifyConfigVal, ok := notifyConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_config expected to be basetypes.ObjectValue, was: %T`, notifyConfigAttribute))
	}

	notifyEmailAttribute, ok := attributes["notify_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_email is missing from object`)

		return nil, diags
	}

	notifyEmailVal, ok := notifyEmailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_email expected to be basetypes.StringValue, was: %T`, notifyEmailAttribute))
	}

	onlyProxy404Attribute, ok := attributes["only_proxy_404"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`only_proxy_404 is missing from object`)

		return nil, diags
	}

	onlyProxy404Val, ok := onlyProxy404Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`only_proxy_404 expected to be basetypes.BoolValue, was: %T`, onlyProxy404Attribute))
	}

	originTimeoutAttribute, ok := attributes["origin_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`origin_timeout is missing from object`)

		return nil, diags
	}

	originTimeoutVal, ok := originTimeoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`origin_timeout expected to be basetypes.StringValue, was: %T`, originTimeoutAttribute))
	}

	proxyAlertEnabledAttribute, ok := attributes["proxy_alert_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_alert_enabled is missing from object`)

		return nil, diags
	}

	proxyAlertEnabledVal, ok := proxyAlertEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_alert_enabled expected to be basetypes.BoolValue, was: %T`, proxyAlertEnabledAttribute))
	}

	proxyStripHeadersAttribute, ok := attributes["proxy_strip_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_strip_headers is missing from object`)

		return nil, diags
	}

	proxyStripHeadersVal, ok := proxyStripHeadersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_strip_headers expected to be basetypes.ListValue, was: %T`, proxyStripHeadersAttribute))
	}

	proxyStripRequestHeadersAttribute, ok := attributes["proxy_strip_request_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_strip_request_headers is missing from object`)

		return nil, diags
	}

	proxyStripRequestHeadersVal, ok := proxyStripRequestHeadersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_strip_request_headers expected to be basetypes.ListValue, was: %T`, proxyStripRequestHeadersAttribute))
	}

	toAttribute, ok := attributes["to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to is missing from object`)

		return nil, diags
	}

	toVal, ok := toAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to expected to be basetypes.StringValue, was: %T`, toAttribute))
	}

	wafConfigAttribute, ok := attributes["waf_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_config is missing from object`)

		return nil, diags
	}

	wafConfigVal, ok := wafConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_config expected to be basetypes.ObjectValue, was: %T`, wafConfigAttribute))
	}

	wafEnabledAttribute, ok := attributes["waf_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_enabled is missing from object`)

		return nil, diags
	}

	wafEnabledVal, ok := wafEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_enabled expected to be basetypes.BoolValue, was: %T`, wafEnabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionConfigValue{
		AuthPass:                  authPassVal,
		AuthUser:                  authUserVal,
		CacheLifetime:             cacheLifetimeVal,
		DisableSslVerify:          disableSslVerifyVal,
		FailoverLifetime:          failoverLifetimeVal,
		FailoverMode:              failoverModeVal,
		FailoverOriginStatusCodes: failoverOriginStatusCodesVal,
		FailoverOriginTtfb:        failoverOriginTtfbVal,
		Host:                      hostVal,
		InjectHeaders:             injectHeadersVal,
		Notify:                    notifyVal,
		NotifyConfig:              notifyConfigVal,
		NotifyEmail:               notifyEmailVal,
		OnlyProxy404:              onlyProxy404Val,
		OriginTimeout:             originTimeoutVal,
		ProxyAlertEnabled:         proxyAlertEnabledVal,
		ProxyStripHeaders:         proxyStripHeadersVal,
		ProxyStripRequestHeaders:  proxyStripRequestHeadersVal,
		To:                        toVal,
		WafConfig:                 wafConfigVal,
		WafEnabled:                wafEnabledVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewActionConfigValueNull() ActionConfigValue {
	return ActionConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewActionConfigValueUnknown() ActionConfigValue {
	return ActionConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionConfigValue Attribute Value",
				"While creating a ActionConfigValue value, a missing attribute value was detected. "+
					"A ActionConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionConfigValue Attribute Type",
				"While creating a ActionConfigValue value, an invalid attribute value was detected. "+
					"A ActionConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionConfigValue Attribute Value",
				"While creating a ActionConfigValue value, an extra attribute value was detected. "+
					"A ActionConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionConfigValueUnknown(), diags
	}

	authPassAttribute, ok := attributes["auth_pass"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_pass is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	authPassVal, ok := authPassAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_pass expected to be basetypes.StringValue, was: %T`, authPassAttribute))
	}

	authUserAttribute, ok := attributes["auth_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_user is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	authUserVal, ok := authUserAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_user expected to be basetypes.StringValue, was: %T`, authUserAttribute))
	}

	cacheLifetimeAttribute, ok := attributes["cache_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cache_lifetime is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	cacheLifetimeVal, ok := cacheLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cache_lifetime expected to be basetypes.Int64Value, was: %T`, cacheLifetimeAttribute))
	}

	disableSslVerifyAttribute, ok := attributes["disable_ssl_verify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_ssl_verify is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	disableSslVerifyVal, ok := disableSslVerifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_ssl_verify expected to be basetypes.BoolValue, was: %T`, disableSslVerifyAttribute))
	}

	failoverLifetimeAttribute, ok := attributes["failover_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_lifetime is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	failoverLifetimeVal, ok := failoverLifetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_lifetime expected to be basetypes.StringValue, was: %T`, failoverLifetimeAttribute))
	}

	failoverModeAttribute, ok := attributes["failover_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_mode is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	failoverModeVal, ok := failoverModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_mode expected to be basetypes.BoolValue, was: %T`, failoverModeAttribute))
	}

	failoverOriginStatusCodesAttribute, ok := attributes["failover_origin_status_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_origin_status_codes is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	failoverOriginStatusCodesVal, ok := failoverOriginStatusCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_origin_status_codes expected to be basetypes.ListValue, was: %T`, failoverOriginStatusCodesAttribute))
	}

	failoverOriginTtfbAttribute, ok := attributes["failover_origin_ttfb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_origin_ttfb is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	failoverOriginTtfbVal, ok := failoverOriginTtfbAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_origin_ttfb expected to be basetypes.StringValue, was: %T`, failoverOriginTtfbAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	injectHeadersAttribute, ok := attributes["inject_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inject_headers is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	injectHeadersVal, ok := injectHeadersAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inject_headers expected to be basetypes.MapValue, was: %T`, injectHeadersAttribute))
	}

	notifyAttribute, ok := attributes["notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	notifyVal, ok := notifyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify expected to be basetypes.StringValue, was: %T`, notifyAttribute))
	}

	notifyConfigAttribute, ok := attributes["notify_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_config is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	notifyConfigVal, ok := notifyConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_config expected to be basetypes.ObjectValue, was: %T`, notifyConfigAttribute))
	}

	notifyEmailAttribute, ok := attributes["notify_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_email is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	notifyEmailVal, ok := notifyEmailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_email expected to be basetypes.StringValue, was: %T`, notifyEmailAttribute))
	}

	onlyProxy404Attribute, ok := attributes["only_proxy_404"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`only_proxy_404 is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	onlyProxy404Val, ok := onlyProxy404Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`only_proxy_404 expected to be basetypes.BoolValue, was: %T`, onlyProxy404Attribute))
	}

	originTimeoutAttribute, ok := attributes["origin_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`origin_timeout is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	originTimeoutVal, ok := originTimeoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`origin_timeout expected to be basetypes.StringValue, was: %T`, originTimeoutAttribute))
	}

	proxyAlertEnabledAttribute, ok := attributes["proxy_alert_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_alert_enabled is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	proxyAlertEnabledVal, ok := proxyAlertEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_alert_enabled expected to be basetypes.BoolValue, was: %T`, proxyAlertEnabledAttribute))
	}

	proxyStripHeadersAttribute, ok := attributes["proxy_strip_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_strip_headers is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	proxyStripHeadersVal, ok := proxyStripHeadersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_strip_headers expected to be basetypes.ListValue, was: %T`, proxyStripHeadersAttribute))
	}

	proxyStripRequestHeadersAttribute, ok := attributes["proxy_strip_request_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_strip_request_headers is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	proxyStripRequestHeadersVal, ok := proxyStripRequestHeadersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_strip_request_headers expected to be basetypes.ListValue, was: %T`, proxyStripRequestHeadersAttribute))
	}

	toAttribute, ok := attributes["to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	toVal, ok := toAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to expected to be basetypes.StringValue, was: %T`, toAttribute))
	}

	wafConfigAttribute, ok := attributes["waf_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_config is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	wafConfigVal, ok := wafConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_config expected to be basetypes.ObjectValue, was: %T`, wafConfigAttribute))
	}

	wafEnabledAttribute, ok := attributes["waf_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_enabled is missing from object`)

		return NewActionConfigValueUnknown(), diags
	}

	wafEnabledVal, ok := wafEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_enabled expected to be basetypes.BoolValue, was: %T`, wafEnabledAttribute))
	}

	if diags.HasError() {
		return NewActionConfigValueUnknown(), diags
	}

	return ActionConfigValue{
		AuthPass:                  authPassVal,
		AuthUser:                  authUserVal,
		CacheLifetime:             cacheLifetimeVal,
		DisableSslVerify:          disableSslVerifyVal,
		FailoverLifetime:          failoverLifetimeVal,
		FailoverMode:              failoverModeVal,
		FailoverOriginStatusCodes: failoverOriginStatusCodesVal,
		FailoverOriginTtfb:        failoverOriginTtfbVal,
		Host:                      hostVal,
		InjectHeaders:             injectHeadersVal,
		Notify:                    notifyVal,
		NotifyConfig:              notifyConfigVal,
		NotifyEmail:               notifyEmailVal,
		OnlyProxy404:              onlyProxy404Val,
		OriginTimeout:             originTimeoutVal,
		ProxyAlertEnabled:         proxyAlertEnabledVal,
		ProxyStripHeaders:         proxyStripHeadersVal,
		ProxyStripRequestHeaders:  proxyStripRequestHeadersVal,
		To:                        toVal,
		WafConfig:                 wafConfigVal,
		WafEnabled:                wafEnabledVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewActionConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionConfigValue {
	object, diags := NewActionConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionConfigValueMust(ActionConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionConfigType) ValueType(ctx context.Context) attr.Value {
	return ActionConfigValue{}
}

var _ basetypes.ObjectValuable = ActionConfigValue{}

type ActionConfigValue struct {
	AuthPass                  basetypes.StringValue `tfsdk:"auth_pass"`
	AuthUser                  basetypes.StringValue `tfsdk:"auth_user"`
	CacheLifetime             basetypes.Int64Value  `tfsdk:"cache_lifetime"`
	DisableSslVerify          basetypes.BoolValue   `tfsdk:"disable_ssl_verify"`
	FailoverLifetime          basetypes.StringValue `tfsdk:"failover_lifetime"`
	FailoverMode              basetypes.BoolValue   `tfsdk:"failover_mode"`
	FailoverOriginStatusCodes basetypes.ListValue   `tfsdk:"failover_origin_status_codes"`
	FailoverOriginTtfb        basetypes.StringValue `tfsdk:"failover_origin_ttfb"`
	Host                      basetypes.StringValue `tfsdk:"host"`
	InjectHeaders             basetypes.MapValue    `tfsdk:"inject_headers"`
	Notify                    basetypes.StringValue `tfsdk:"notify"`
	NotifyConfig              basetypes.ObjectValue `tfsdk:"notify_config"`
	NotifyEmail               basetypes.StringValue `tfsdk:"notify_email"`
	OnlyProxy404              basetypes.BoolValue   `tfsdk:"only_proxy_404"`
	OriginTimeout             basetypes.StringValue `tfsdk:"origin_timeout"`
	ProxyAlertEnabled         basetypes.BoolValue   `tfsdk:"proxy_alert_enabled"`
	ProxyStripHeaders         basetypes.ListValue   `tfsdk:"proxy_strip_headers"`
	ProxyStripRequestHeaders  basetypes.ListValue   `tfsdk:"proxy_strip_request_headers"`
	To                        basetypes.StringValue `tfsdk:"to"`
	WafConfig                 basetypes.ObjectValue `tfsdk:"waf_config"`
	WafEnabled                basetypes.BoolValue   `tfsdk:"waf_enabled"`
	state                     attr.ValueState
}

func (v ActionConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 21)

	var val tftypes.Value
	var err error

	attrTypes["auth_pass"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auth_user"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cache_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_ssl_verify"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["failover_lifetime"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["failover_mode"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["failover_origin_status_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["failover_origin_ttfb"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["inject_headers"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["notify"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_config"] = basetypes.ObjectType{
		AttrTypes: NotifyConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["notify_email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["only_proxy_404"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["origin_timeout"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["proxy_alert_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["proxy_strip_headers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["proxy_strip_request_headers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["to"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["waf_config"] = basetypes.ObjectType{
		AttrTypes: WafConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["waf_enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 21)

		val, err = v.AuthPass.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_pass"] = val

		val, err = v.AuthUser.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_user"] = val

		val, err = v.CacheLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cache_lifetime"] = val

		val, err = v.DisableSslVerify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_ssl_verify"] = val

		val, err = v.FailoverLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failover_lifetime"] = val

		val, err = v.FailoverMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failover_mode"] = val

		val, err = v.FailoverOriginStatusCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failover_origin_status_codes"] = val

		val, err = v.FailoverOriginTtfb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failover_origin_ttfb"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.InjectHeaders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inject_headers"] = val

		val, err = v.Notify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify"] = val

		val, err = v.NotifyConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_config"] = val

		val, err = v.NotifyEmail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_email"] = val

		val, err = v.OnlyProxy404.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["only_proxy_404"] = val

		val, err = v.OriginTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["origin_timeout"] = val

		val, err = v.ProxyAlertEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_alert_enabled"] = val

		val, err = v.ProxyStripHeaders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_strip_headers"] = val

		val, err = v.ProxyStripRequestHeaders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_strip_request_headers"] = val

		val, err = v.To.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to"] = val

		val, err = v.WafConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_config"] = val

		val, err = v.WafEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionConfigValue) String() string {
	return "ActionConfigValue"
}

func (v ActionConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var notifyConfig basetypes.ObjectValue

	if v.NotifyConfig.IsNull() {
		notifyConfig = types.ObjectNull(
			NotifyConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.NotifyConfig.IsUnknown() {
		notifyConfig = types.ObjectUnknown(
			NotifyConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.NotifyConfig.IsNull() && !v.NotifyConfig.IsUnknown() {
		notifyConfig = types.ObjectValueMust(
			NotifyConfigValue{}.AttributeTypes(ctx),
			v.NotifyConfig.Attributes(),
		)
	}

	var wafConfig basetypes.ObjectValue

	if v.WafConfig.IsNull() {
		wafConfig = types.ObjectNull(
			WafConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.WafConfig.IsUnknown() {
		wafConfig = types.ObjectUnknown(
			WafConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.WafConfig.IsNull() && !v.WafConfig.IsUnknown() {
		wafConfig = types.ObjectValueMust(
			WafConfigValue{}.AttributeTypes(ctx),
			v.WafConfig.Attributes(),
		)
	}

	failoverOriginStatusCodesVal, d := types.ListValue(types.StringType, v.FailoverOriginStatusCodes.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auth_pass":          basetypes.StringType{},
			"auth_user":          basetypes.StringType{},
			"cache_lifetime":     basetypes.Int64Type{},
			"disable_ssl_verify": basetypes.BoolType{},
			"failover_lifetime":  basetypes.StringType{},
			"failover_mode":      basetypes.BoolType{},
			"failover_origin_status_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"failover_origin_ttfb": basetypes.StringType{},
			"host":                 basetypes.StringType{},
			"inject_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notify": basetypes.StringType{},
			"notify_config": basetypes.ObjectType{
				AttrTypes: NotifyConfigValue{}.AttributeTypes(ctx),
			},
			"notify_email":        basetypes.StringType{},
			"only_proxy_404":      basetypes.BoolType{},
			"origin_timeout":      basetypes.StringType{},
			"proxy_alert_enabled": basetypes.BoolType{},
			"proxy_strip_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_strip_request_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"to": basetypes.StringType{},
			"waf_config": basetypes.ObjectType{
				AttrTypes: WafConfigValue{}.AttributeTypes(ctx),
			},
			"waf_enabled": basetypes.BoolType{},
		}), diags
	}

	injectHeadersVal, d := types.MapValue(types.StringType, v.InjectHeaders.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auth_pass":          basetypes.StringType{},
			"auth_user":          basetypes.StringType{},
			"cache_lifetime":     basetypes.Int64Type{},
			"disable_ssl_verify": basetypes.BoolType{},
			"failover_lifetime":  basetypes.StringType{},
			"failover_mode":      basetypes.BoolType{},
			"failover_origin_status_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"failover_origin_ttfb": basetypes.StringType{},
			"host":                 basetypes.StringType{},
			"inject_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notify": basetypes.StringType{},
			"notify_config": basetypes.ObjectType{
				AttrTypes: NotifyConfigValue{}.AttributeTypes(ctx),
			},
			"notify_email":        basetypes.StringType{},
			"only_proxy_404":      basetypes.BoolType{},
			"origin_timeout":      basetypes.StringType{},
			"proxy_alert_enabled": basetypes.BoolType{},
			"proxy_strip_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_strip_request_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"to": basetypes.StringType{},
			"waf_config": basetypes.ObjectType{
				AttrTypes: WafConfigValue{}.AttributeTypes(ctx),
			},
			"waf_enabled": basetypes.BoolType{},
		}), diags
	}

	proxyStripHeadersVal, d := types.ListValue(types.StringType, v.ProxyStripHeaders.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auth_pass":          basetypes.StringType{},
			"auth_user":          basetypes.StringType{},
			"cache_lifetime":     basetypes.Int64Type{},
			"disable_ssl_verify": basetypes.BoolType{},
			"failover_lifetime":  basetypes.StringType{},
			"failover_mode":      basetypes.BoolType{},
			"failover_origin_status_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"failover_origin_ttfb": basetypes.StringType{},
			"host":                 basetypes.StringType{},
			"inject_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notify": basetypes.StringType{},
			"notify_config": basetypes.ObjectType{
				AttrTypes: NotifyConfigValue{}.AttributeTypes(ctx),
			},
			"notify_email":        basetypes.StringType{},
			"only_proxy_404":      basetypes.BoolType{},
			"origin_timeout":      basetypes.StringType{},
			"proxy_alert_enabled": basetypes.BoolType{},
			"proxy_strip_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_strip_request_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"to": basetypes.StringType{},
			"waf_config": basetypes.ObjectType{
				AttrTypes: WafConfigValue{}.AttributeTypes(ctx),
			},
			"waf_enabled": basetypes.BoolType{},
		}), diags
	}

	proxyStripRequestHeadersVal, d := types.ListValue(types.StringType, v.ProxyStripRequestHeaders.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auth_pass":          basetypes.StringType{},
			"auth_user":          basetypes.StringType{},
			"cache_lifetime":     basetypes.Int64Type{},
			"disable_ssl_verify": basetypes.BoolType{},
			"failover_lifetime":  basetypes.StringType{},
			"failover_mode":      basetypes.BoolType{},
			"failover_origin_status_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"failover_origin_ttfb": basetypes.StringType{},
			"host":                 basetypes.StringType{},
			"inject_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notify": basetypes.StringType{},
			"notify_config": basetypes.ObjectType{
				AttrTypes: NotifyConfigValue{}.AttributeTypes(ctx),
			},
			"notify_email":        basetypes.StringType{},
			"only_proxy_404":      basetypes.BoolType{},
			"origin_timeout":      basetypes.StringType{},
			"proxy_alert_enabled": basetypes.BoolType{},
			"proxy_strip_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_strip_request_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"to": basetypes.StringType{},
			"waf_config": basetypes.ObjectType{
				AttrTypes: WafConfigValue{}.AttributeTypes(ctx),
			},
			"waf_enabled": basetypes.BoolType{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"auth_pass":          basetypes.StringType{},
			"auth_user":          basetypes.StringType{},
			"cache_lifetime":     basetypes.Int64Type{},
			"disable_ssl_verify": basetypes.BoolType{},
			"failover_lifetime":  basetypes.StringType{},
			"failover_mode":      basetypes.BoolType{},
			"failover_origin_status_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"failover_origin_ttfb": basetypes.StringType{},
			"host":                 basetypes.StringType{},
			"inject_headers": basetypes.MapType{
				ElemType: types.StringType,
			},
			"notify": basetypes.StringType{},
			"notify_config": basetypes.ObjectType{
				AttrTypes: NotifyConfigValue{}.AttributeTypes(ctx),
			},
			"notify_email":        basetypes.StringType{},
			"only_proxy_404":      basetypes.BoolType{},
			"origin_timeout":      basetypes.StringType{},
			"proxy_alert_enabled": basetypes.BoolType{},
			"proxy_strip_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_strip_request_headers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"to": basetypes.StringType{},
			"waf_config": basetypes.ObjectType{
				AttrTypes: WafConfigValue{}.AttributeTypes(ctx),
			},
			"waf_enabled": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"auth_pass":                    v.AuthPass,
			"auth_user":                    v.AuthUser,
			"cache_lifetime":               v.CacheLifetime,
			"disable_ssl_verify":           v.DisableSslVerify,
			"failover_lifetime":            v.FailoverLifetime,
			"failover_mode":                v.FailoverMode,
			"failover_origin_status_codes": failoverOriginStatusCodesVal,
			"failover_origin_ttfb":         v.FailoverOriginTtfb,
			"host":                         v.Host,
			"inject_headers":               injectHeadersVal,
			"notify":                       v.Notify,
			"notify_config":                notifyConfig,
			"notify_email":                 v.NotifyEmail,
			"only_proxy_404":               v.OnlyProxy404,
			"origin_timeout":               v.OriginTimeout,
			"proxy_alert_enabled":          v.ProxyAlertEnabled,
			"proxy_strip_headers":          proxyStripHeadersVal,
			"proxy_strip_request_headers":  proxyStripRequestHeadersVal,
			"to":                           v.To,
			"waf_config":                   wafConfig,
			"waf_enabled":                  v.WafEnabled,
		})

	return objVal, diags
}

func (v ActionConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthPass.Equal(other.AuthPass) {
		return false
	}

	if !v.AuthUser.Equal(other.AuthUser) {
		return false
	}

	if !v.CacheLifetime.Equal(other.CacheLifetime) {
		return false
	}

	if !v.DisableSslVerify.Equal(other.DisableSslVerify) {
		return false
	}

	if !v.FailoverLifetime.Equal(other.FailoverLifetime) {
		return false
	}

	if !v.FailoverMode.Equal(other.FailoverMode) {
		return false
	}

	if !v.FailoverOriginStatusCodes.Equal(other.FailoverOriginStatusCodes) {
		return false
	}

	if !v.FailoverOriginTtfb.Equal(other.FailoverOriginTtfb) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.InjectHeaders.Equal(other.InjectHeaders) {
		return false
	}

	if !v.Notify.Equal(other.Notify) {
		return false
	}

	if !v.NotifyConfig.Equal(other.NotifyConfig) {
		return false
	}

	if !v.NotifyEmail.Equal(other.NotifyEmail) {
		return false
	}

	if !v.OnlyProxy404.Equal(other.OnlyProxy404) {
		return false
	}

	if !v.OriginTimeout.Equal(other.OriginTimeout) {
		return false
	}

	if !v.ProxyAlertEnabled.Equal(other.ProxyAlertEnabled) {
		return false
	}

	if !v.ProxyStripHeaders.Equal(other.ProxyStripHeaders) {
		return false
	}

	if !v.ProxyStripRequestHeaders.Equal(other.ProxyStripRequestHeaders) {
		return false
	}

	if !v.To.Equal(other.To) {
		return false
	}

	if !v.WafConfig.Equal(other.WafConfig) {
		return false
	}

	if !v.WafEnabled.Equal(other.WafEnabled) {
		return false
	}

	return true
}

func (v ActionConfigValue) Type(ctx context.Context) attr.Type {
	return ActionConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_pass":          basetypes.StringType{},
		"auth_user":          basetypes.StringType{},
		"cache_lifetime":     basetypes.Int64Type{},
		"disable_ssl_verify": basetypes.BoolType{},
		"failover_lifetime":  basetypes.StringType{},
		"failover_mode":      basetypes.BoolType{},
		"failover_origin_status_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"failover_origin_ttfb": basetypes.StringType{},
		"host":                 basetypes.StringType{},
		"inject_headers": basetypes.MapType{
			ElemType: types.StringType,
		},
		"notify": basetypes.StringType{},
		"notify_config": basetypes.ObjectType{
			AttrTypes: NotifyConfigValue{}.AttributeTypes(ctx),
		},
		"notify_email":        basetypes.StringType{},
		"only_proxy_404":      basetypes.BoolType{},
		"origin_timeout":      basetypes.StringType{},
		"proxy_alert_enabled": basetypes.BoolType{},
		"proxy_strip_headers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"proxy_strip_request_headers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"to": basetypes.StringType{},
		"waf_config": basetypes.ObjectType{
			AttrTypes: WafConfigValue{}.AttributeTypes(ctx),
		},
		"waf_enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = NotifyConfigType{}

type NotifyConfigType struct {
	basetypes.ObjectType
}

func (t NotifyConfigType) Equal(o attr.Type) bool {
	other, ok := o.(NotifyConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NotifyConfigType) String() string {
	return "NotifyConfigType"
}

func (t NotifyConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	originStatusCodesAttribute, ok := attributes["origin_status_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`origin_status_codes is missing from object`)

		return nil, diags
	}

	originStatusCodesVal, ok := originStatusCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`origin_status_codes expected to be basetypes.ListValue, was: %T`, originStatusCodesAttribute))
	}

	periodAttribute, ok := attributes["period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`period is missing from object`)

		return nil, diags
	}

	periodVal, ok := periodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`period expected to be basetypes.StringValue, was: %T`, periodAttribute))
	}

	slackWebhookAttribute, ok := attributes["slack_webhook"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slack_webhook is missing from object`)

		return nil, diags
	}

	slackWebhookVal, ok := slackWebhookAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slack_webhook expected to be basetypes.StringValue, was: %T`, slackWebhookAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NotifyConfigValue{
		OriginStatusCodes: originStatusCodesVal,
		Period:            periodVal,
		SlackWebhook:      slackWebhookVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNotifyConfigValueNull() NotifyConfigValue {
	return NotifyConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewNotifyConfigValueUnknown() NotifyConfigValue {
	return NotifyConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNotifyConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NotifyConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NotifyConfigValue Attribute Value",
				"While creating a NotifyConfigValue value, a missing attribute value was detected. "+
					"A NotifyConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NotifyConfigValue Attribute Type",
				"While creating a NotifyConfigValue value, an invalid attribute value was detected. "+
					"A NotifyConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NotifyConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NotifyConfigValue Attribute Value",
				"While creating a NotifyConfigValue value, an extra attribute value was detected. "+
					"A NotifyConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NotifyConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNotifyConfigValueUnknown(), diags
	}

	originStatusCodesAttribute, ok := attributes["origin_status_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`origin_status_codes is missing from object`)

		return NewNotifyConfigValueUnknown(), diags
	}

	originStatusCodesVal, ok := originStatusCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`origin_status_codes expected to be basetypes.ListValue, was: %T`, originStatusCodesAttribute))
	}

	periodAttribute, ok := attributes["period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`period is missing from object`)

		return NewNotifyConfigValueUnknown(), diags
	}

	periodVal, ok := periodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`period expected to be basetypes.StringValue, was: %T`, periodAttribute))
	}

	slackWebhookAttribute, ok := attributes["slack_webhook"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slack_webhook is missing from object`)

		return NewNotifyConfigValueUnknown(), diags
	}

	slackWebhookVal, ok := slackWebhookAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slack_webhook expected to be basetypes.StringValue, was: %T`, slackWebhookAttribute))
	}

	if diags.HasError() {
		return NewNotifyConfigValueUnknown(), diags
	}

	return NotifyConfigValue{
		OriginStatusCodes: originStatusCodesVal,
		Period:            periodVal,
		SlackWebhook:      slackWebhookVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNotifyConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NotifyConfigValue {
	object, diags := NewNotifyConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNotifyConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NotifyConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNotifyConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNotifyConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNotifyConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNotifyConfigValueMust(NotifyConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NotifyConfigType) ValueType(ctx context.Context) attr.Value {
	return NotifyConfigValue{}
}

var _ basetypes.ObjectValuable = NotifyConfigValue{}

type NotifyConfigValue struct {
	OriginStatusCodes basetypes.ListValue   `tfsdk:"origin_status_codes"`
	Period            basetypes.StringValue `tfsdk:"period"`
	SlackWebhook      basetypes.StringValue `tfsdk:"slack_webhook"`
	state             attr.ValueState
}

func (v NotifyConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["origin_status_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["period"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slack_webhook"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.OriginStatusCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["origin_status_codes"] = val

		val, err = v.Period.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["period"] = val

		val, err = v.SlackWebhook.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slack_webhook"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NotifyConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NotifyConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NotifyConfigValue) String() string {
	return "NotifyConfigValue"
}

func (v NotifyConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	originStatusCodesVal, d := types.ListValue(types.StringType, v.OriginStatusCodes.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"origin_status_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"period":        basetypes.StringType{},
			"slack_webhook": basetypes.StringType{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"origin_status_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"period":        basetypes.StringType{},
			"slack_webhook": basetypes.StringType{},
		},
		map[string]attr.Value{
			"origin_status_codes": originStatusCodesVal,
			"period":              v.Period,
			"slack_webhook":       v.SlackWebhook,
		})

	return objVal, diags
}

func (v NotifyConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(NotifyConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OriginStatusCodes.Equal(other.OriginStatusCodes) {
		return false
	}

	if !v.Period.Equal(other.Period) {
		return false
	}

	if !v.SlackWebhook.Equal(other.SlackWebhook) {
		return false
	}

	return true
}

func (v NotifyConfigValue) Type(ctx context.Context) attr.Type {
	return NotifyConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NotifyConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"origin_status_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"period":        basetypes.StringType{},
		"slack_webhook": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = WafConfigType{}

type WafConfigType struct {
	basetypes.ObjectType
}

func (t WafConfigType) Equal(o attr.Type) bool {
	other, ok := o.(WafConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WafConfigType) String() string {
	return "WafConfigType"
}

func (t WafConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowIpAttribute, ok := attributes["allow_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ip is missing from object`)

		return nil, diags
	}

	allowIpVal, ok := allowIpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ip expected to be basetypes.ListValue, was: %T`, allowIpAttribute))
	}

	allowRulesAttribute, ok := attributes["allow_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rules is missing from object`)

		return nil, diags
	}

	allowRulesVal, ok := allowRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rules expected to be basetypes.ListValue, was: %T`, allowRulesAttribute))
	}

	blockIpAttribute, ok := attributes["block_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_ip is missing from object`)

		return nil, diags
	}

	blockIpVal, ok := blockIpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_ip expected to be basetypes.ListValue, was: %T`, blockIpAttribute))
	}

	blockListsAttribute, ok := attributes["block_lists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_lists is missing from object`)

		return nil, diags
	}

	blockListsVal, ok := blockListsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_lists expected to be basetypes.ObjectValue, was: %T`, blockListsAttribute))
	}

	blockRefererAttribute, ok := attributes["block_referer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_referer is missing from object`)

		return nil, diags
	}

	blockRefererVal, ok := blockRefererAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_referer expected to be basetypes.ListValue, was: %T`, blockRefererAttribute))
	}

	blockUaAttribute, ok := attributes["block_ua"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_ua is missing from object`)

		return nil, diags
	}

	blockUaVal, ok := blockUaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_ua expected to be basetypes.ListValue, was: %T`, blockUaAttribute))
	}

	httpblAttribute, ok := attributes["httpbl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl is missing from object`)

		return nil, diags
	}

	httpblVal, ok := httpblAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl expected to be basetypes.ObjectValue, was: %T`, httpblAttribute))
	}

	httpblEnabledAttribute, ok := attributes["httpbl_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl_enabled is missing from object`)

		return nil, diags
	}

	httpblEnabledVal, ok := httpblEnabledAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl_enabled expected to be basetypes.MapValue, was: %T`, httpblEnabledAttribute))
	}

	ipRatelimitCooldownAttribute, ok := attributes["ip_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_cooldown is missing from object`)

		return nil, diags
	}

	ipRatelimitCooldownVal, ok := ipRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, ipRatelimitCooldownAttribute))
	}

	ipRatelimitModeAttribute, ok := attributes["ip_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_mode is missing from object`)

		return nil, diags
	}

	ipRatelimitModeVal, ok := ipRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_mode expected to be basetypes.StringValue, was: %T`, ipRatelimitModeAttribute))
	}

	ipRatelimitRpsAttribute, ok := attributes["ip_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_rps is missing from object`)

		return nil, diags
	}

	ipRatelimitRpsVal, ok := ipRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, ipRatelimitRpsAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	notifyEmailAttribute, ok := attributes["notify_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_email is missing from object`)

		return nil, diags
	}

	notifyEmailVal, ok := notifyEmailAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_email expected to be basetypes.ListValue, was: %T`, notifyEmailAttribute))
	}

	notifySlackAttribute, ok := attributes["notify_slack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack is missing from object`)

		return nil, diags
	}

	notifySlackVal, ok := notifySlackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack expected to be basetypes.StringValue, was: %T`, notifySlackAttribute))
	}

	notifySlackHitsRpmAttribute, ok := attributes["notify_slack_hits_rpm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack_hits_rpm is missing from object`)

		return nil, diags
	}

	notifySlackHitsRpmVal, ok := notifySlackHitsRpmAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack_hits_rpm expected to be basetypes.Int64Value, was: %T`, notifySlackHitsRpmAttribute))
	}

	notifySlackRpmAttribute, ok := attributes["notify_slack_rpm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack_rpm is missing from object`)

		return nil, diags
	}

	notifySlackRpmVal, ok := notifySlackRpmAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack_rpm expected to be basetypes.Int64Value, was: %T`, notifySlackRpmAttribute))
	}

	paranoiaLevelAttribute, ok := attributes["paranoia_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paranoia_level is missing from object`)

		return nil, diags
	}

	paranoiaLevelVal, ok := paranoiaLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paranoia_level expected to be basetypes.Int64Value, was: %T`, paranoiaLevelAttribute))
	}

	requestHeaderNameAttribute, ok := attributes["request_header_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_name is missing from object`)

		return nil, diags
	}

	requestHeaderNameVal, ok := requestHeaderNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_name expected to be basetypes.StringValue, was: %T`, requestHeaderNameAttribute))
	}

	requestHeaderRatelimitCooldownAttribute, ok := attributes["request_header_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_cooldown is missing from object`)

		return nil, diags
	}

	requestHeaderRatelimitCooldownVal, ok := requestHeaderRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, requestHeaderRatelimitCooldownAttribute))
	}

	requestHeaderRatelimitModeAttribute, ok := attributes["request_header_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_mode is missing from object`)

		return nil, diags
	}

	requestHeaderRatelimitModeVal, ok := requestHeaderRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_mode expected to be basetypes.StringValue, was: %T`, requestHeaderRatelimitModeAttribute))
	}

	requestHeaderRatelimitRpsAttribute, ok := attributes["request_header_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_rps is missing from object`)

		return nil, diags
	}

	requestHeaderRatelimitRpsVal, ok := requestHeaderRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, requestHeaderRatelimitRpsAttribute))
	}

	thresholdsAttribute, ok := attributes["thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thresholds is missing from object`)

		return nil, diags
	}

	thresholdsVal, ok := thresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thresholds expected to be basetypes.ListValue, was: %T`, thresholdsAttribute))
	}

	wafRatelimitCooldownAttribute, ok := attributes["waf_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_cooldown is missing from object`)

		return nil, diags
	}

	wafRatelimitCooldownVal, ok := wafRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, wafRatelimitCooldownAttribute))
	}

	wafRatelimitHitsAttribute, ok := attributes["waf_ratelimit_hits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_hits is missing from object`)

		return nil, diags
	}

	wafRatelimitHitsVal, ok := wafRatelimitHitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_hits expected to be basetypes.Int64Value, was: %T`, wafRatelimitHitsAttribute))
	}

	wafRatelimitModeAttribute, ok := attributes["waf_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_mode is missing from object`)

		return nil, diags
	}

	wafRatelimitModeVal, ok := wafRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_mode expected to be basetypes.StringValue, was: %T`, wafRatelimitModeAttribute))
	}

	wafRatelimitRpsAttribute, ok := attributes["waf_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_rps is missing from object`)

		return nil, diags
	}

	wafRatelimitRpsVal, ok := wafRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, wafRatelimitRpsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WafConfigValue{
		AllowIp:                        allowIpVal,
		AllowRules:                     allowRulesVal,
		BlockIp:                        blockIpVal,
		BlockLists:                     blockListsVal,
		BlockReferer:                   blockRefererVal,
		BlockUa:                        blockUaVal,
		Httpbl:                         httpblVal,
		HttpblEnabled:                  httpblEnabledVal,
		IpRatelimitCooldown:            ipRatelimitCooldownVal,
		IpRatelimitMode:                ipRatelimitModeVal,
		IpRatelimitRps:                 ipRatelimitRpsVal,
		Mode:                           modeVal,
		NotifyEmail:                    notifyEmailVal,
		NotifySlack:                    notifySlackVal,
		NotifySlackHitsRpm:             notifySlackHitsRpmVal,
		NotifySlackRpm:                 notifySlackRpmVal,
		ParanoiaLevel:                  paranoiaLevelVal,
		RequestHeaderName:              requestHeaderNameVal,
		RequestHeaderRatelimitCooldown: requestHeaderRatelimitCooldownVal,
		RequestHeaderRatelimitMode:     requestHeaderRatelimitModeVal,
		RequestHeaderRatelimitRps:      requestHeaderRatelimitRpsVal,
		Thresholds:                     thresholdsVal,
		WafRatelimitCooldown:           wafRatelimitCooldownVal,
		WafRatelimitHits:               wafRatelimitHitsVal,
		WafRatelimitMode:               wafRatelimitModeVal,
		WafRatelimitRps:                wafRatelimitRpsVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewWafConfigValueNull() WafConfigValue {
	return WafConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewWafConfigValueUnknown() WafConfigValue {
	return WafConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWafConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WafConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WafConfigValue Attribute Value",
				"While creating a WafConfigValue value, a missing attribute value was detected. "+
					"A WafConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WafConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WafConfigValue Attribute Type",
				"While creating a WafConfigValue value, an invalid attribute value was detected. "+
					"A WafConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WafConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WafConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WafConfigValue Attribute Value",
				"While creating a WafConfigValue value, an extra attribute value was detected. "+
					"A WafConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WafConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWafConfigValueUnknown(), diags
	}

	allowIpAttribute, ok := attributes["allow_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ip is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	allowIpVal, ok := allowIpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ip expected to be basetypes.ListValue, was: %T`, allowIpAttribute))
	}

	allowRulesAttribute, ok := attributes["allow_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rules is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	allowRulesVal, ok := allowRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rules expected to be basetypes.ListValue, was: %T`, allowRulesAttribute))
	}

	blockIpAttribute, ok := attributes["block_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_ip is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	blockIpVal, ok := blockIpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_ip expected to be basetypes.ListValue, was: %T`, blockIpAttribute))
	}

	blockListsAttribute, ok := attributes["block_lists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_lists is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	blockListsVal, ok := blockListsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_lists expected to be basetypes.ObjectValue, was: %T`, blockListsAttribute))
	}

	blockRefererAttribute, ok := attributes["block_referer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_referer is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	blockRefererVal, ok := blockRefererAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_referer expected to be basetypes.ListValue, was: %T`, blockRefererAttribute))
	}

	blockUaAttribute, ok := attributes["block_ua"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_ua is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	blockUaVal, ok := blockUaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_ua expected to be basetypes.ListValue, was: %T`, blockUaAttribute))
	}

	httpblAttribute, ok := attributes["httpbl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	httpblVal, ok := httpblAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl expected to be basetypes.ObjectValue, was: %T`, httpblAttribute))
	}

	httpblEnabledAttribute, ok := attributes["httpbl_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl_enabled is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	httpblEnabledVal, ok := httpblEnabledAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl_enabled expected to be basetypes.MapValue, was: %T`, httpblEnabledAttribute))
	}

	ipRatelimitCooldownAttribute, ok := attributes["ip_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_cooldown is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	ipRatelimitCooldownVal, ok := ipRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, ipRatelimitCooldownAttribute))
	}

	ipRatelimitModeAttribute, ok := attributes["ip_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_mode is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	ipRatelimitModeVal, ok := ipRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_mode expected to be basetypes.StringValue, was: %T`, ipRatelimitModeAttribute))
	}

	ipRatelimitRpsAttribute, ok := attributes["ip_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_rps is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	ipRatelimitRpsVal, ok := ipRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, ipRatelimitRpsAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	notifyEmailAttribute, ok := attributes["notify_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_email is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	notifyEmailVal, ok := notifyEmailAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_email expected to be basetypes.ListValue, was: %T`, notifyEmailAttribute))
	}

	notifySlackAttribute, ok := attributes["notify_slack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	notifySlackVal, ok := notifySlackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack expected to be basetypes.StringValue, was: %T`, notifySlackAttribute))
	}

	notifySlackHitsRpmAttribute, ok := attributes["notify_slack_hits_rpm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack_hits_rpm is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	notifySlackHitsRpmVal, ok := notifySlackHitsRpmAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack_hits_rpm expected to be basetypes.Int64Value, was: %T`, notifySlackHitsRpmAttribute))
	}

	notifySlackRpmAttribute, ok := attributes["notify_slack_rpm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack_rpm is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	notifySlackRpmVal, ok := notifySlackRpmAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack_rpm expected to be basetypes.Int64Value, was: %T`, notifySlackRpmAttribute))
	}

	paranoiaLevelAttribute, ok := attributes["paranoia_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paranoia_level is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	paranoiaLevelVal, ok := paranoiaLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paranoia_level expected to be basetypes.Int64Value, was: %T`, paranoiaLevelAttribute))
	}

	requestHeaderNameAttribute, ok := attributes["request_header_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_name is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	requestHeaderNameVal, ok := requestHeaderNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_name expected to be basetypes.StringValue, was: %T`, requestHeaderNameAttribute))
	}

	requestHeaderRatelimitCooldownAttribute, ok := attributes["request_header_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_cooldown is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	requestHeaderRatelimitCooldownVal, ok := requestHeaderRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, requestHeaderRatelimitCooldownAttribute))
	}

	requestHeaderRatelimitModeAttribute, ok := attributes["request_header_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_mode is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	requestHeaderRatelimitModeVal, ok := requestHeaderRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_mode expected to be basetypes.StringValue, was: %T`, requestHeaderRatelimitModeAttribute))
	}

	requestHeaderRatelimitRpsAttribute, ok := attributes["request_header_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_rps is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	requestHeaderRatelimitRpsVal, ok := requestHeaderRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, requestHeaderRatelimitRpsAttribute))
	}

	thresholdsAttribute, ok := attributes["thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thresholds is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	thresholdsVal, ok := thresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thresholds expected to be basetypes.ListValue, was: %T`, thresholdsAttribute))
	}

	wafRatelimitCooldownAttribute, ok := attributes["waf_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_cooldown is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	wafRatelimitCooldownVal, ok := wafRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, wafRatelimitCooldownAttribute))
	}

	wafRatelimitHitsAttribute, ok := attributes["waf_ratelimit_hits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_hits is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	wafRatelimitHitsVal, ok := wafRatelimitHitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_hits expected to be basetypes.Int64Value, was: %T`, wafRatelimitHitsAttribute))
	}

	wafRatelimitModeAttribute, ok := attributes["waf_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_mode is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	wafRatelimitModeVal, ok := wafRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_mode expected to be basetypes.StringValue, was: %T`, wafRatelimitModeAttribute))
	}

	wafRatelimitRpsAttribute, ok := attributes["waf_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_rps is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	wafRatelimitRpsVal, ok := wafRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, wafRatelimitRpsAttribute))
	}

	if diags.HasError() {
		return NewWafConfigValueUnknown(), diags
	}

	return WafConfigValue{
		AllowIp:                        allowIpVal,
		AllowRules:                     allowRulesVal,
		BlockIp:                        blockIpVal,
		BlockLists:                     blockListsVal,
		BlockReferer:                   blockRefererVal,
		BlockUa:                        blockUaVal,
		Httpbl:                         httpblVal,
		HttpblEnabled:                  httpblEnabledVal,
		IpRatelimitCooldown:            ipRatelimitCooldownVal,
		IpRatelimitMode:                ipRatelimitModeVal,
		IpRatelimitRps:                 ipRatelimitRpsVal,
		Mode:                           modeVal,
		NotifyEmail:                    notifyEmailVal,
		NotifySlack:                    notifySlackVal,
		NotifySlackHitsRpm:             notifySlackHitsRpmVal,
		NotifySlackRpm:                 notifySlackRpmVal,
		ParanoiaLevel:                  paranoiaLevelVal,
		RequestHeaderName:              requestHeaderNameVal,
		RequestHeaderRatelimitCooldown: requestHeaderRatelimitCooldownVal,
		RequestHeaderRatelimitMode:     requestHeaderRatelimitModeVal,
		RequestHeaderRatelimitRps:      requestHeaderRatelimitRpsVal,
		Thresholds:                     thresholdsVal,
		WafRatelimitCooldown:           wafRatelimitCooldownVal,
		WafRatelimitHits:               wafRatelimitHitsVal,
		WafRatelimitMode:               wafRatelimitModeVal,
		WafRatelimitRps:                wafRatelimitRpsVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewWafConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WafConfigValue {
	object, diags := NewWafConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWafConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WafConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWafConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWafConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWafConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWafConfigValueMust(WafConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WafConfigType) ValueType(ctx context.Context) attr.Value {
	return WafConfigValue{}
}

var _ basetypes.ObjectValuable = WafConfigValue{}

type WafConfigValue struct {
	AllowIp                        basetypes.ListValue   `tfsdk:"allow_ip"`
	AllowRules                     basetypes.ListValue   `tfsdk:"allow_rules"`
	BlockIp                        basetypes.ListValue   `tfsdk:"block_ip"`
	BlockLists                     basetypes.ObjectValue `tfsdk:"block_lists"`
	BlockReferer                   basetypes.ListValue   `tfsdk:"block_referer"`
	BlockUa                        basetypes.ListValue   `tfsdk:"block_ua"`
	Httpbl                         basetypes.ObjectValue `tfsdk:"httpbl"`
	HttpblEnabled                  basetypes.MapValue    `tfsdk:"httpbl_enabled"`
	IpRatelimitCooldown            basetypes.Int64Value  `tfsdk:"ip_ratelimit_cooldown"`
	IpRatelimitMode                basetypes.StringValue `tfsdk:"ip_ratelimit_mode"`
	IpRatelimitRps                 basetypes.Int64Value  `tfsdk:"ip_ratelimit_rps"`
	Mode                           basetypes.StringValue `tfsdk:"mode"`
	NotifyEmail                    basetypes.ListValue   `tfsdk:"notify_email"`
	NotifySlack                    basetypes.StringValue `tfsdk:"notify_slack"`
	NotifySlackHitsRpm             basetypes.Int64Value  `tfsdk:"notify_slack_hits_rpm"`
	NotifySlackRpm                 basetypes.Int64Value  `tfsdk:"notify_slack_rpm"`
	ParanoiaLevel                  basetypes.Int64Value  `tfsdk:"paranoia_level"`
	RequestHeaderName              basetypes.StringValue `tfsdk:"request_header_name"`
	RequestHeaderRatelimitCooldown basetypes.Int64Value  `tfsdk:"request_header_ratelimit_cooldown"`
	RequestHeaderRatelimitMode     basetypes.StringValue `tfsdk:"request_header_ratelimit_mode"`
	RequestHeaderRatelimitRps      basetypes.Int64Value  `tfsdk:"request_header_ratelimit_rps"`
	Thresholds                     basetypes.ListValue   `tfsdk:"thresholds"`
	WafRatelimitCooldown           basetypes.Int64Value  `tfsdk:"waf_ratelimit_cooldown"`
	WafRatelimitHits               basetypes.Int64Value  `tfsdk:"waf_ratelimit_hits"`
	WafRatelimitMode               basetypes.StringValue `tfsdk:"waf_ratelimit_mode"`
	WafRatelimitRps                basetypes.Int64Value  `tfsdk:"waf_ratelimit_rps"`
	state                          attr.ValueState
}

func (v WafConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 26)

	var val tftypes.Value
	var err error

	attrTypes["allow_ip"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["allow_rules"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["block_ip"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["block_lists"] = basetypes.ObjectType{
		AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["block_referer"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["block_ua"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["httpbl"] = basetypes.ObjectType{
		AttrTypes: HttpblValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["httpbl_enabled"] = basetypes.MapType{
		ElemType: types.BoolType,
	}.TerraformType(ctx)
	attrTypes["ip_ratelimit_cooldown"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ip_ratelimit_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_ratelimit_rps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_email"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["notify_slack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_slack_hits_rpm"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["notify_slack_rpm"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["paranoia_level"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["request_header_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["request_header_ratelimit_cooldown"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["request_header_ratelimit_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["request_header_ratelimit_rps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["thresholds"] = basetypes.ListType{
		ElemType: ThresholdsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["waf_ratelimit_cooldown"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["waf_ratelimit_hits"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["waf_ratelimit_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["waf_ratelimit_rps"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 26)

		val, err = v.AllowIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_ip"] = val

		val, err = v.AllowRules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rules"] = val

		val, err = v.BlockIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_ip"] = val

		val, err = v.BlockLists.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_lists"] = val

		val, err = v.BlockReferer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_referer"] = val

		val, err = v.BlockUa.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_ua"] = val

		val, err = v.Httpbl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["httpbl"] = val

		val, err = v.HttpblEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["httpbl_enabled"] = val

		val, err = v.IpRatelimitCooldown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_ratelimit_cooldown"] = val

		val, err = v.IpRatelimitMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_ratelimit_mode"] = val

		val, err = v.IpRatelimitRps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_ratelimit_rps"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.NotifyEmail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_email"] = val

		val, err = v.NotifySlack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_slack"] = val

		val, err = v.NotifySlackHitsRpm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_slack_hits_rpm"] = val

		val, err = v.NotifySlackRpm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_slack_rpm"] = val

		val, err = v.ParanoiaLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paranoia_level"] = val

		val, err = v.RequestHeaderName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_header_name"] = val

		val, err = v.RequestHeaderRatelimitCooldown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_header_ratelimit_cooldown"] = val

		val, err = v.RequestHeaderRatelimitMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_header_ratelimit_mode"] = val

		val, err = v.RequestHeaderRatelimitRps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_header_ratelimit_rps"] = val

		val, err = v.Thresholds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["thresholds"] = val

		val, err = v.WafRatelimitCooldown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_ratelimit_cooldown"] = val

		val, err = v.WafRatelimitHits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_ratelimit_hits"] = val

		val, err = v.WafRatelimitMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_ratelimit_mode"] = val

		val, err = v.WafRatelimitRps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_ratelimit_rps"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WafConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WafConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WafConfigValue) String() string {
	return "WafConfigValue"
}

func (v WafConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var blockLists basetypes.ObjectValue

	if v.BlockLists.IsNull() {
		blockLists = types.ObjectNull(
			BlockListsValue{}.AttributeTypes(ctx),
		)
	}

	if v.BlockLists.IsUnknown() {
		blockLists = types.ObjectUnknown(
			BlockListsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BlockLists.IsNull() && !v.BlockLists.IsUnknown() {
		blockLists = types.ObjectValueMust(
			BlockListsValue{}.AttributeTypes(ctx),
			v.BlockLists.Attributes(),
		)
	}

	var httpbl basetypes.ObjectValue

	if v.Httpbl.IsNull() {
		httpbl = types.ObjectNull(
			HttpblValue{}.AttributeTypes(ctx),
		)
	}

	if v.Httpbl.IsUnknown() {
		httpbl = types.ObjectUnknown(
			HttpblValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Httpbl.IsNull() && !v.Httpbl.IsUnknown() {
		httpbl = types.ObjectValueMust(
			HttpblValue{}.AttributeTypes(ctx),
			v.Httpbl.Attributes(),
		)
	}

	thresholds := types.ListValueMust(
		ThresholdsType{
			basetypes.ObjectType{
				AttrTypes: ThresholdsValue{}.AttributeTypes(ctx),
			},
		},
		v.Thresholds.Elements(),
	)

	if v.Thresholds.IsNull() {
		thresholds = types.ListNull(
			ThresholdsType{
				basetypes.ObjectType{
					AttrTypes: ThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Thresholds.IsUnknown() {
		thresholds = types.ListUnknown(
			ThresholdsType{
				basetypes.ObjectType{
					AttrTypes: ThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	allowIpVal, d := types.ListValue(types.StringType, v.AllowIp.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	allowRulesVal, d := types.ListValue(types.StringType, v.AllowRules.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	blockIpVal, d := types.ListValue(types.StringType, v.BlockIp.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	blockRefererVal, d := types.ListValue(types.StringType, v.BlockReferer.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	blockUaVal, d := types.ListValue(types.StringType, v.BlockUa.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	httpblEnabledVal, d := types.MapValue(types.BoolType, v.HttpblEnabled.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	notifyEmailVal, d := types.ListValue(types.StringType, v.NotifyEmail.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"allow_ip":                          allowIpVal,
			"allow_rules":                       allowRulesVal,
			"block_ip":                          blockIpVal,
			"block_lists":                       blockLists,
			"block_referer":                     blockRefererVal,
			"block_ua":                          blockUaVal,
			"httpbl":                            httpbl,
			"httpbl_enabled":                    httpblEnabledVal,
			"ip_ratelimit_cooldown":             v.IpRatelimitCooldown,
			"ip_ratelimit_mode":                 v.IpRatelimitMode,
			"ip_ratelimit_rps":                  v.IpRatelimitRps,
			"mode":                              v.Mode,
			"notify_email":                      notifyEmailVal,
			"notify_slack":                      v.NotifySlack,
			"notify_slack_hits_rpm":             v.NotifySlackHitsRpm,
			"notify_slack_rpm":                  v.NotifySlackRpm,
			"paranoia_level":                    v.ParanoiaLevel,
			"request_header_name":               v.RequestHeaderName,
			"request_header_ratelimit_cooldown": v.RequestHeaderRatelimitCooldown,
			"request_header_ratelimit_mode":     v.RequestHeaderRatelimitMode,
			"request_header_ratelimit_rps":      v.RequestHeaderRatelimitRps,
			"thresholds":                        thresholds,
			"waf_ratelimit_cooldown":            v.WafRatelimitCooldown,
			"waf_ratelimit_hits":                v.WafRatelimitHits,
			"waf_ratelimit_mode":                v.WafRatelimitMode,
			"waf_ratelimit_rps":                 v.WafRatelimitRps,
		})

	return objVal, diags
}

func (v WafConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(WafConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowIp.Equal(other.AllowIp) {
		return false
	}

	if !v.AllowRules.Equal(other.AllowRules) {
		return false
	}

	if !v.BlockIp.Equal(other.BlockIp) {
		return false
	}

	if !v.BlockLists.Equal(other.BlockLists) {
		return false
	}

	if !v.BlockReferer.Equal(other.BlockReferer) {
		return false
	}

	if !v.BlockUa.Equal(other.BlockUa) {
		return false
	}

	if !v.Httpbl.Equal(other.Httpbl) {
		return false
	}

	if !v.HttpblEnabled.Equal(other.HttpblEnabled) {
		return false
	}

	if !v.IpRatelimitCooldown.Equal(other.IpRatelimitCooldown) {
		return false
	}

	if !v.IpRatelimitMode.Equal(other.IpRatelimitMode) {
		return false
	}

	if !v.IpRatelimitRps.Equal(other.IpRatelimitRps) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.NotifyEmail.Equal(other.NotifyEmail) {
		return false
	}

	if !v.NotifySlack.Equal(other.NotifySlack) {
		return false
	}

	if !v.NotifySlackHitsRpm.Equal(other.NotifySlackHitsRpm) {
		return false
	}

	if !v.NotifySlackRpm.Equal(other.NotifySlackRpm) {
		return false
	}

	if !v.ParanoiaLevel.Equal(other.ParanoiaLevel) {
		return false
	}

	if !v.RequestHeaderName.Equal(other.RequestHeaderName) {
		return false
	}

	if !v.RequestHeaderRatelimitCooldown.Equal(other.RequestHeaderRatelimitCooldown) {
		return false
	}

	if !v.RequestHeaderRatelimitMode.Equal(other.RequestHeaderRatelimitMode) {
		return false
	}

	if !v.RequestHeaderRatelimitRps.Equal(other.RequestHeaderRatelimitRps) {
		return false
	}

	if !v.Thresholds.Equal(other.Thresholds) {
		return false
	}

	if !v.WafRatelimitCooldown.Equal(other.WafRatelimitCooldown) {
		return false
	}

	if !v.WafRatelimitHits.Equal(other.WafRatelimitHits) {
		return false
	}

	if !v.WafRatelimitMode.Equal(other.WafRatelimitMode) {
		return false
	}

	if !v.WafRatelimitRps.Equal(other.WafRatelimitRps) {
		return false
	}

	return true
}

func (v WafConfigValue) Type(ctx context.Context) attr.Type {
	return WafConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WafConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_ip": basetypes.ListType{
			ElemType: types.StringType,
		},
		"allow_rules": basetypes.ListType{
			ElemType: types.StringType,
		},
		"block_ip": basetypes.ListType{
			ElemType: types.StringType,
		},
		"block_lists": basetypes.ObjectType{
			AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
		},
		"block_referer": basetypes.ListType{
			ElemType: types.StringType,
		},
		"block_ua": basetypes.ListType{
			ElemType: types.StringType,
		},
		"httpbl": basetypes.ObjectType{
			AttrTypes: HttpblValue{}.AttributeTypes(ctx),
		},
		"httpbl_enabled": basetypes.MapType{
			ElemType: types.BoolType,
		},
		"ip_ratelimit_cooldown": basetypes.Int64Type{},
		"ip_ratelimit_mode":     basetypes.StringType{},
		"ip_ratelimit_rps":      basetypes.Int64Type{},
		"mode":                  basetypes.StringType{},
		"notify_email": basetypes.ListType{
			ElemType: types.StringType,
		},
		"notify_slack":                      basetypes.StringType{},
		"notify_slack_hits_rpm":             basetypes.Int64Type{},
		"notify_slack_rpm":                  basetypes.Int64Type{},
		"paranoia_level":                    basetypes.Int64Type{},
		"request_header_name":               basetypes.StringType{},
		"request_header_ratelimit_cooldown": basetypes.Int64Type{},
		"request_header_ratelimit_mode":     basetypes.StringType{},
		"request_header_ratelimit_rps":      basetypes.Int64Type{},
		"thresholds": basetypes.ListType{
			ElemType: ThresholdsValue{}.Type(ctx),
		},
		"waf_ratelimit_cooldown": basetypes.Int64Type{},
		"waf_ratelimit_hits":     basetypes.Int64Type{},
		"waf_ratelimit_mode":     basetypes.StringType{},
		"waf_ratelimit_rps":      basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BlockListsType{}

type BlockListsType struct {
	basetypes.ObjectType
}

func (t BlockListsType) Equal(o attr.Type) bool {
	other, ok := o.(BlockListsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BlockListsType) String() string {
	return "BlockListsType"
}

func (t BlockListsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aiAttribute, ok := attributes["ai"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ai is missing from object`)

		return nil, diags
	}

	aiVal, ok := aiAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ai expected to be basetypes.BoolValue, was: %T`, aiAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.BoolValue, was: %T`, ipAttribute))
	}

	refererAttribute, ok := attributes["referer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`referer is missing from object`)

		return nil, diags
	}

	refererVal, ok := refererAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`referer expected to be basetypes.BoolValue, was: %T`, refererAttribute))
	}

	userAgentAttribute, ok := attributes["user_agent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_agent is missing from object`)

		return nil, diags
	}

	userAgentVal, ok := userAgentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_agent expected to be basetypes.BoolValue, was: %T`, userAgentAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BlockListsValue{
		Ai:        aiVal,
		Ip:        ipVal,
		Referer:   refererVal,
		UserAgent: userAgentVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewBlockListsValueNull() BlockListsValue {
	return BlockListsValue{
		state: attr.ValueStateNull,
	}
}

func NewBlockListsValueUnknown() BlockListsValue {
	return BlockListsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBlockListsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BlockListsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BlockListsValue Attribute Value",
				"While creating a BlockListsValue value, a missing attribute value was detected. "+
					"A BlockListsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlockListsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BlockListsValue Attribute Type",
				"While creating a BlockListsValue value, an invalid attribute value was detected. "+
					"A BlockListsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlockListsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BlockListsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BlockListsValue Attribute Value",
				"While creating a BlockListsValue value, an extra attribute value was detected. "+
					"A BlockListsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BlockListsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBlockListsValueUnknown(), diags
	}

	aiAttribute, ok := attributes["ai"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ai is missing from object`)

		return NewBlockListsValueUnknown(), diags
	}

	aiVal, ok := aiAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ai expected to be basetypes.BoolValue, was: %T`, aiAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewBlockListsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.BoolValue, was: %T`, ipAttribute))
	}

	refererAttribute, ok := attributes["referer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`referer is missing from object`)

		return NewBlockListsValueUnknown(), diags
	}

	refererVal, ok := refererAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`referer expected to be basetypes.BoolValue, was: %T`, refererAttribute))
	}

	userAgentAttribute, ok := attributes["user_agent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_agent is missing from object`)

		return NewBlockListsValueUnknown(), diags
	}

	userAgentVal, ok := userAgentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_agent expected to be basetypes.BoolValue, was: %T`, userAgentAttribute))
	}

	if diags.HasError() {
		return NewBlockListsValueUnknown(), diags
	}

	return BlockListsValue{
		Ai:        aiVal,
		Ip:        ipVal,
		Referer:   refererVal,
		UserAgent: userAgentVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewBlockListsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BlockListsValue {
	object, diags := NewBlockListsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBlockListsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BlockListsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBlockListsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBlockListsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBlockListsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBlockListsValueMust(BlockListsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BlockListsType) ValueType(ctx context.Context) attr.Value {
	return BlockListsValue{}
}

var _ basetypes.ObjectValuable = BlockListsValue{}

type BlockListsValue struct {
	Ai        basetypes.BoolValue `tfsdk:"ai"`
	Ip        basetypes.BoolValue `tfsdk:"ip"`
	Referer   basetypes.BoolValue `tfsdk:"referer"`
	UserAgent basetypes.BoolValue `tfsdk:"user_agent"`
	state     attr.ValueState
}

func (v BlockListsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ai"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["referer"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["user_agent"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Ai.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ai"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Referer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["referer"] = val

		val, err = v.UserAgent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_agent"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BlockListsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BlockListsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BlockListsValue) String() string {
	return "BlockListsValue"
}

func (v BlockListsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"ai":         basetypes.BoolType{},
			"ip":         basetypes.BoolType{},
			"referer":    basetypes.BoolType{},
			"user_agent": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"ai":         v.Ai,
			"ip":         v.Ip,
			"referer":    v.Referer,
			"user_agent": v.UserAgent,
		})

	return objVal, diags
}

func (v BlockListsValue) Equal(o attr.Value) bool {
	other, ok := o.(BlockListsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ai.Equal(other.Ai) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Referer.Equal(other.Referer) {
		return false
	}

	if !v.UserAgent.Equal(other.UserAgent) {
		return false
	}

	return true
}

func (v BlockListsValue) Type(ctx context.Context) attr.Type {
	return BlockListsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BlockListsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ai":         basetypes.BoolType{},
		"ip":         basetypes.BoolType{},
		"referer":    basetypes.BoolType{},
		"user_agent": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = HttpblType{}

type HttpblType struct {
	basetypes.ObjectType
}

func (t HttpblType) Equal(o attr.Type) bool {
	other, ok := o.(HttpblType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HttpblType) String() string {
	return "HttpblType"
}

func (t HttpblType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return nil, diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	blockHarvesterAttribute, ok := attributes["block_harvester"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_harvester is missing from object`)

		return nil, diags
	}

	blockHarvesterVal, ok := blockHarvesterAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_harvester expected to be basetypes.BoolValue, was: %T`, blockHarvesterAttribute))
	}

	blockSearchEngineAttribute, ok := attributes["block_search_engine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_search_engine is missing from object`)

		return nil, diags
	}

	blockSearchEngineVal, ok := blockSearchEngineAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_search_engine expected to be basetypes.BoolValue, was: %T`, blockSearchEngineAttribute))
	}

	blockSpamAttribute, ok := attributes["block_spam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_spam is missing from object`)

		return nil, diags
	}

	blockSpamVal, ok := blockSpamAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_spam expected to be basetypes.BoolValue, was: %T`, blockSpamAttribute))
	}

	blockSuspiciousAttribute, ok := attributes["block_suspicious"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_suspicious is missing from object`)

		return nil, diags
	}

	blockSuspiciousVal, ok := blockSuspiciousAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_suspicious expected to be basetypes.BoolValue, was: %T`, blockSuspiciousAttribute))
	}

	httpblEnabledAttribute, ok := attributes["httpbl_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl_enabled is missing from object`)

		return nil, diags
	}

	httpblEnabledVal, ok := httpblEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl_enabled expected to be basetypes.BoolValue, was: %T`, httpblEnabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HttpblValue{
		ApiKey:            apiKeyVal,
		BlockHarvester:    blockHarvesterVal,
		BlockSearchEngine: blockSearchEngineVal,
		BlockSpam:         blockSpamVal,
		BlockSuspicious:   blockSuspiciousVal,
		HttpblEnabled:     httpblEnabledVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewHttpblValueNull() HttpblValue {
	return HttpblValue{
		state: attr.ValueStateNull,
	}
}

func NewHttpblValueUnknown() HttpblValue {
	return HttpblValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHttpblValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HttpblValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HttpblValue Attribute Value",
				"While creating a HttpblValue value, a missing attribute value was detected. "+
					"A HttpblValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HttpblValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HttpblValue Attribute Type",
				"While creating a HttpblValue value, an invalid attribute value was detected. "+
					"A HttpblValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HttpblValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HttpblValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HttpblValue Attribute Value",
				"While creating a HttpblValue value, an extra attribute value was detected. "+
					"A HttpblValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HttpblValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHttpblValueUnknown(), diags
	}

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	blockHarvesterAttribute, ok := attributes["block_harvester"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_harvester is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	blockHarvesterVal, ok := blockHarvesterAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_harvester expected to be basetypes.BoolValue, was: %T`, blockHarvesterAttribute))
	}

	blockSearchEngineAttribute, ok := attributes["block_search_engine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_search_engine is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	blockSearchEngineVal, ok := blockSearchEngineAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_search_engine expected to be basetypes.BoolValue, was: %T`, blockSearchEngineAttribute))
	}

	blockSpamAttribute, ok := attributes["block_spam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_spam is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	blockSpamVal, ok := blockSpamAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_spam expected to be basetypes.BoolValue, was: %T`, blockSpamAttribute))
	}

	blockSuspiciousAttribute, ok := attributes["block_suspicious"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_suspicious is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	blockSuspiciousVal, ok := blockSuspiciousAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_suspicious expected to be basetypes.BoolValue, was: %T`, blockSuspiciousAttribute))
	}

	httpblEnabledAttribute, ok := attributes["httpbl_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl_enabled is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	httpblEnabledVal, ok := httpblEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl_enabled expected to be basetypes.BoolValue, was: %T`, httpblEnabledAttribute))
	}

	if diags.HasError() {
		return NewHttpblValueUnknown(), diags
	}

	return HttpblValue{
		ApiKey:            apiKeyVal,
		BlockHarvester:    blockHarvesterVal,
		BlockSearchEngine: blockSearchEngineVal,
		BlockSpam:         blockSpamVal,
		BlockSuspicious:   blockSuspiciousVal,
		HttpblEnabled:     httpblEnabledVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewHttpblValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HttpblValue {
	object, diags := NewHttpblValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHttpblValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HttpblType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHttpblValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHttpblValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHttpblValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHttpblValueMust(HttpblValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HttpblType) ValueType(ctx context.Context) attr.Value {
	return HttpblValue{}
}

var _ basetypes.ObjectValuable = HttpblValue{}

type HttpblValue struct {
	ApiKey            basetypes.StringValue `tfsdk:"api_key"`
	BlockHarvester    basetypes.BoolValue   `tfsdk:"block_harvester"`
	BlockSearchEngine basetypes.BoolValue   `tfsdk:"block_search_engine"`
	BlockSpam         basetypes.BoolValue   `tfsdk:"block_spam"`
	BlockSuspicious   basetypes.BoolValue   `tfsdk:"block_suspicious"`
	HttpblEnabled     basetypes.BoolValue   `tfsdk:"httpbl_enabled"`
	state             attr.ValueState
}

func (v HttpblValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["block_harvester"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["block_search_engine"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["block_spam"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["block_suspicious"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["httpbl_enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.ApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_key"] = val

		val, err = v.BlockHarvester.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_harvester"] = val

		val, err = v.BlockSearchEngine.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_search_engine"] = val

		val, err = v.BlockSpam.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_spam"] = val

		val, err = v.BlockSuspicious.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_suspicious"] = val

		val, err = v.HttpblEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["httpbl_enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HttpblValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HttpblValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HttpblValue) String() string {
	return "HttpblValue"
}

func (v HttpblValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"api_key":             basetypes.StringType{},
			"block_harvester":     basetypes.BoolType{},
			"block_search_engine": basetypes.BoolType{},
			"block_spam":          basetypes.BoolType{},
			"block_suspicious":    basetypes.BoolType{},
			"httpbl_enabled":      basetypes.BoolType{},
		},
		map[string]attr.Value{
			"api_key":             v.ApiKey,
			"block_harvester":     v.BlockHarvester,
			"block_search_engine": v.BlockSearchEngine,
			"block_spam":          v.BlockSpam,
			"block_suspicious":    v.BlockSuspicious,
			"httpbl_enabled":      v.HttpblEnabled,
		})

	return objVal, diags
}

func (v HttpblValue) Equal(o attr.Value) bool {
	other, ok := o.(HttpblValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiKey.Equal(other.ApiKey) {
		return false
	}

	if !v.BlockHarvester.Equal(other.BlockHarvester) {
		return false
	}

	if !v.BlockSearchEngine.Equal(other.BlockSearchEngine) {
		return false
	}

	if !v.BlockSpam.Equal(other.BlockSpam) {
		return false
	}

	if !v.BlockSuspicious.Equal(other.BlockSuspicious) {
		return false
	}

	if !v.HttpblEnabled.Equal(other.HttpblEnabled) {
		return false
	}

	return true
}

func (v HttpblValue) Type(ctx context.Context) attr.Type {
	return HttpblType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HttpblValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_key":             basetypes.StringType{},
		"block_harvester":     basetypes.BoolType{},
		"block_search_engine": basetypes.BoolType{},
		"block_spam":          basetypes.BoolType{},
		"block_suspicious":    basetypes.BoolType{},
		"httpbl_enabled":      basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ThresholdsType{}

type ThresholdsType struct {
	basetypes.ObjectType
}

func (t ThresholdsType) Equal(o attr.Type) bool {
	other, ok := o.(ThresholdsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ThresholdsType) String() string {
	return "ThresholdsType"
}

func (t ThresholdsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cooldownAttribute, ok := attributes["cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown is missing from object`)

		return nil, diags
	}

	cooldownVal, ok := cooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown expected to be basetypes.Int64Value, was: %T`, cooldownAttribute))
	}

	hitsAttribute, ok := attributes["hits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hits is missing from object`)

		return nil, diags
	}

	hitsVal, ok := hitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hits expected to be basetypes.Int64Value, was: %T`, hitsAttribute))
	}

	minutesAttribute, ok := attributes["minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minutes is missing from object`)

		return nil, diags
	}

	minutesVal, ok := minutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minutes expected to be basetypes.Int64Value, was: %T`, minutesAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	notifySlackAttribute, ok := attributes["notify_slack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack is missing from object`)

		return nil, diags
	}

	notifySlackVal, ok := notifySlackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack expected to be basetypes.StringValue, was: %T`, notifySlackAttribute))
	}

	rpsAttribute, ok := attributes["rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rps is missing from object`)

		return nil, diags
	}

	rpsVal, ok := rpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rps expected to be basetypes.Int64Value, was: %T`, rpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ThresholdsValue{
		Cooldown:       cooldownVal,
		Hits:           hitsVal,
		Minutes:        minutesVal,
		Mode:           modeVal,
		NotifySlack:    notifySlackVal,
		Rps:            rpsVal,
		ThresholdsType: typeVal,
		Value:          valueVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewThresholdsValueNull() ThresholdsValue {
	return ThresholdsValue{
		state: attr.ValueStateNull,
	}
}

func NewThresholdsValueUnknown() ThresholdsValue {
	return ThresholdsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewThresholdsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ThresholdsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ThresholdsValue Attribute Value",
				"While creating a ThresholdsValue value, a missing attribute value was detected. "+
					"A ThresholdsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ThresholdsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ThresholdsValue Attribute Type",
				"While creating a ThresholdsValue value, an invalid attribute value was detected. "+
					"A ThresholdsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ThresholdsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ThresholdsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ThresholdsValue Attribute Value",
				"While creating a ThresholdsValue value, an extra attribute value was detected. "+
					"A ThresholdsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ThresholdsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewThresholdsValueUnknown(), diags
	}

	cooldownAttribute, ok := attributes["cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	cooldownVal, ok := cooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown expected to be basetypes.Int64Value, was: %T`, cooldownAttribute))
	}

	hitsAttribute, ok := attributes["hits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hits is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	hitsVal, ok := hitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hits expected to be basetypes.Int64Value, was: %T`, hitsAttribute))
	}

	minutesAttribute, ok := attributes["minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minutes is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	minutesVal, ok := minutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minutes expected to be basetypes.Int64Value, was: %T`, minutesAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	notifySlackAttribute, ok := attributes["notify_slack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	notifySlackVal, ok := notifySlackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack expected to be basetypes.StringValue, was: %T`, notifySlackAttribute))
	}

	rpsAttribute, ok := attributes["rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rps is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	rpsVal, ok := rpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rps expected to be basetypes.Int64Value, was: %T`, rpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewThresholdsValueUnknown(), diags
	}

	return ThresholdsValue{
		Cooldown:       cooldownVal,
		Hits:           hitsVal,
		Minutes:        minutesVal,
		Mode:           modeVal,
		NotifySlack:    notifySlackVal,
		Rps:            rpsVal,
		ThresholdsType: typeVal,
		Value:          valueVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewThresholdsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ThresholdsValue {
	object, diags := NewThresholdsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewThresholdsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ThresholdsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewThresholdsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewThresholdsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewThresholdsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewThresholdsValueMust(ThresholdsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ThresholdsType) ValueType(ctx context.Context) attr.Value {
	return ThresholdsValue{}
}

var _ basetypes.ObjectValuable = ThresholdsValue{}

type ThresholdsValue struct {
	Cooldown       basetypes.Int64Value  `tfsdk:"cooldown"`
	Hits           basetypes.Int64Value  `tfsdk:"hits"`
	Minutes        basetypes.Int64Value  `tfsdk:"minutes"`
	Mode           basetypes.StringValue `tfsdk:"mode"`
	NotifySlack    basetypes.StringValue `tfsdk:"notify_slack"`
	Rps            basetypes.Int64Value  `tfsdk:"rps"`
	ThresholdsType basetypes.StringValue `tfsdk:"type"`
	Value          basetypes.StringValue `tfsdk:"value"`
	state          attr.ValueState
}

func (v ThresholdsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cooldown"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hits"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minutes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_slack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Cooldown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cooldown"] = val

		val, err = v.Hits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hits"] = val

		val, err = v.Minutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minutes"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.NotifySlack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_slack"] = val

		val, err = v.Rps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rps"] = val

		val, err = v.ThresholdsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ThresholdsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ThresholdsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ThresholdsValue) String() string {
	return "ThresholdsValue"
}

func (v ThresholdsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cooldown":     basetypes.Int64Type{},
			"hits":         basetypes.Int64Type{},
			"minutes":      basetypes.Int64Type{},
			"mode":         basetypes.StringType{},
			"notify_slack": basetypes.StringType{},
			"rps":          basetypes.Int64Type{},
			"type":         basetypes.StringType{},
			"value":        basetypes.StringType{},
		},
		map[string]attr.Value{
			"cooldown":     v.Cooldown,
			"hits":         v.Hits,
			"minutes":      v.Minutes,
			"mode":         v.Mode,
			"notify_slack": v.NotifySlack,
			"rps":          v.Rps,
			"type":         v.ThresholdsType,
			"value":        v.Value,
		})

	return objVal, diags
}

func (v ThresholdsValue) Equal(o attr.Value) bool {
	other, ok := o.(ThresholdsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cooldown.Equal(other.Cooldown) {
		return false
	}

	if !v.Hits.Equal(other.Hits) {
		return false
	}

	if !v.Minutes.Equal(other.Minutes) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.NotifySlack.Equal(other.NotifySlack) {
		return false
	}

	if !v.Rps.Equal(other.Rps) {
		return false
	}

	if !v.ThresholdsType.Equal(other.ThresholdsType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ThresholdsValue) Type(ctx context.Context) attr.Type {
	return ThresholdsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ThresholdsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cooldown":     basetypes.Int64Type{},
		"hits":         basetypes.Int64Type{},
		"minutes":      basetypes.Int64Type{},
		"mode":         basetypes.StringType{},
		"notify_slack": basetypes.StringType{},
		"rps":          basetypes.Int64Type{},
		"type":         basetypes.StringType{},
		"value":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NotifyConfigType{}

type NotifyConfigType struct {
	basetypes.ObjectType
}

func (t NotifyConfigType) Equal(o attr.Type) bool {
	other, ok := o.(NotifyConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NotifyConfigType) String() string {
	return "NotifyConfigType"
}

func (t NotifyConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	originStatusCodesAttribute, ok := attributes["origin_status_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`origin_status_codes is missing from object`)

		return nil, diags
	}

	originStatusCodesVal, ok := originStatusCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`origin_status_codes expected to be basetypes.ListValue, was: %T`, originStatusCodesAttribute))
	}

	periodAttribute, ok := attributes["period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`period is missing from object`)

		return nil, diags
	}

	periodVal, ok := periodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`period expected to be basetypes.StringValue, was: %T`, periodAttribute))
	}

	slackWebhookAttribute, ok := attributes["slack_webhook"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slack_webhook is missing from object`)

		return nil, diags
	}

	slackWebhookVal, ok := slackWebhookAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slack_webhook expected to be basetypes.StringValue, was: %T`, slackWebhookAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NotifyConfigValue{
		OriginStatusCodes: originStatusCodesVal,
		Period:            periodVal,
		SlackWebhook:      slackWebhookVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNotifyConfigValueNull() NotifyConfigValue {
	return NotifyConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewNotifyConfigValueUnknown() NotifyConfigValue {
	return NotifyConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNotifyConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NotifyConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NotifyConfigValue Attribute Value",
				"While creating a NotifyConfigValue value, a missing attribute value was detected. "+
					"A NotifyConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NotifyConfigValue Attribute Type",
				"While creating a NotifyConfigValue value, an invalid attribute value was detected. "+
					"A NotifyConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NotifyConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NotifyConfigValue Attribute Value",
				"While creating a NotifyConfigValue value, an extra attribute value was detected. "+
					"A NotifyConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NotifyConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNotifyConfigValueUnknown(), diags
	}

	originStatusCodesAttribute, ok := attributes["origin_status_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`origin_status_codes is missing from object`)

		return NewNotifyConfigValueUnknown(), diags
	}

	originStatusCodesVal, ok := originStatusCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`origin_status_codes expected to be basetypes.ListValue, was: %T`, originStatusCodesAttribute))
	}

	periodAttribute, ok := attributes["period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`period is missing from object`)

		return NewNotifyConfigValueUnknown(), diags
	}

	periodVal, ok := periodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`period expected to be basetypes.StringValue, was: %T`, periodAttribute))
	}

	slackWebhookAttribute, ok := attributes["slack_webhook"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slack_webhook is missing from object`)

		return NewNotifyConfigValueUnknown(), diags
	}

	slackWebhookVal, ok := slackWebhookAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slack_webhook expected to be basetypes.StringValue, was: %T`, slackWebhookAttribute))
	}

	if diags.HasError() {
		return NewNotifyConfigValueUnknown(), diags
	}

	return NotifyConfigValue{
		OriginStatusCodes: originStatusCodesVal,
		Period:            periodVal,
		SlackWebhook:      slackWebhookVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNotifyConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NotifyConfigValue {
	object, diags := NewNotifyConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNotifyConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NotifyConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNotifyConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNotifyConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNotifyConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNotifyConfigValueMust(NotifyConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NotifyConfigType) ValueType(ctx context.Context) attr.Value {
	return NotifyConfigValue{}
}

var _ basetypes.ObjectValuable = NotifyConfigValue{}

type NotifyConfigValue struct {
	OriginStatusCodes basetypes.ListValue   `tfsdk:"origin_status_codes"`
	Period            basetypes.StringValue `tfsdk:"period"`
	SlackWebhook      basetypes.StringValue `tfsdk:"slack_webhook"`
	state             attr.ValueState
}

func (v NotifyConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["origin_status_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["period"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slack_webhook"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.OriginStatusCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["origin_status_codes"] = val

		val, err = v.Period.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["period"] = val

		val, err = v.SlackWebhook.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slack_webhook"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NotifyConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NotifyConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NotifyConfigValue) String() string {
	return "NotifyConfigValue"
}

func (v NotifyConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	originStatusCodesVal, d := types.ListValue(types.StringType, v.OriginStatusCodes.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"origin_status_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"period":        basetypes.StringType{},
			"slack_webhook": basetypes.StringType{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"origin_status_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"period":        basetypes.StringType{},
			"slack_webhook": basetypes.StringType{},
		},
		map[string]attr.Value{
			"origin_status_codes": originStatusCodesVal,
			"period":              v.Period,
			"slack_webhook":       v.SlackWebhook,
		})

	return objVal, diags
}

func (v NotifyConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(NotifyConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OriginStatusCodes.Equal(other.OriginStatusCodes) {
		return false
	}

	if !v.Period.Equal(other.Period) {
		return false
	}

	if !v.SlackWebhook.Equal(other.SlackWebhook) {
		return false
	}

	return true
}

func (v NotifyConfigValue) Type(ctx context.Context) attr.Type {
	return NotifyConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NotifyConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"origin_status_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"period":        basetypes.StringType{},
		"slack_webhook": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = WafConfigType{}

type WafConfigType struct {
	basetypes.ObjectType
}

func (t WafConfigType) Equal(o attr.Type) bool {
	other, ok := o.(WafConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WafConfigType) String() string {
	return "WafConfigType"
}

func (t WafConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowIpAttribute, ok := attributes["allow_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ip is missing from object`)

		return nil, diags
	}

	allowIpVal, ok := allowIpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ip expected to be basetypes.ListValue, was: %T`, allowIpAttribute))
	}

	allowRulesAttribute, ok := attributes["allow_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rules is missing from object`)

		return nil, diags
	}

	allowRulesVal, ok := allowRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rules expected to be basetypes.ListValue, was: %T`, allowRulesAttribute))
	}

	blockIpAttribute, ok := attributes["block_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_ip is missing from object`)

		return nil, diags
	}

	blockIpVal, ok := blockIpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_ip expected to be basetypes.ListValue, was: %T`, blockIpAttribute))
	}

	blockListsAttribute, ok := attributes["block_lists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_lists is missing from object`)

		return nil, diags
	}

	blockListsVal, ok := blockListsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_lists expected to be basetypes.ObjectValue, was: %T`, blockListsAttribute))
	}

	blockRefererAttribute, ok := attributes["block_referer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_referer is missing from object`)

		return nil, diags
	}

	blockRefererVal, ok := blockRefererAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_referer expected to be basetypes.ListValue, was: %T`, blockRefererAttribute))
	}

	blockUaAttribute, ok := attributes["block_ua"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_ua is missing from object`)

		return nil, diags
	}

	blockUaVal, ok := blockUaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_ua expected to be basetypes.ListValue, was: %T`, blockUaAttribute))
	}

	httpblAttribute, ok := attributes["httpbl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl is missing from object`)

		return nil, diags
	}

	httpblVal, ok := httpblAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl expected to be basetypes.ObjectValue, was: %T`, httpblAttribute))
	}

	httpblEnabledAttribute, ok := attributes["httpbl_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl_enabled is missing from object`)

		return nil, diags
	}

	httpblEnabledVal, ok := httpblEnabledAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl_enabled expected to be basetypes.MapValue, was: %T`, httpblEnabledAttribute))
	}

	ipRatelimitCooldownAttribute, ok := attributes["ip_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_cooldown is missing from object`)

		return nil, diags
	}

	ipRatelimitCooldownVal, ok := ipRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, ipRatelimitCooldownAttribute))
	}

	ipRatelimitModeAttribute, ok := attributes["ip_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_mode is missing from object`)

		return nil, diags
	}

	ipRatelimitModeVal, ok := ipRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_mode expected to be basetypes.StringValue, was: %T`, ipRatelimitModeAttribute))
	}

	ipRatelimitRpsAttribute, ok := attributes["ip_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_rps is missing from object`)

		return nil, diags
	}

	ipRatelimitRpsVal, ok := ipRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, ipRatelimitRpsAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	notifyEmailAttribute, ok := attributes["notify_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_email is missing from object`)

		return nil, diags
	}

	notifyEmailVal, ok := notifyEmailAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_email expected to be basetypes.ListValue, was: %T`, notifyEmailAttribute))
	}

	notifySlackAttribute, ok := attributes["notify_slack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack is missing from object`)

		return nil, diags
	}

	notifySlackVal, ok := notifySlackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack expected to be basetypes.StringValue, was: %T`, notifySlackAttribute))
	}

	notifySlackHitsRpmAttribute, ok := attributes["notify_slack_hits_rpm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack_hits_rpm is missing from object`)

		return nil, diags
	}

	notifySlackHitsRpmVal, ok := notifySlackHitsRpmAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack_hits_rpm expected to be basetypes.Int64Value, was: %T`, notifySlackHitsRpmAttribute))
	}

	notifySlackRpmAttribute, ok := attributes["notify_slack_rpm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack_rpm is missing from object`)

		return nil, diags
	}

	notifySlackRpmVal, ok := notifySlackRpmAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack_rpm expected to be basetypes.Int64Value, was: %T`, notifySlackRpmAttribute))
	}

	paranoiaLevelAttribute, ok := attributes["paranoia_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paranoia_level is missing from object`)

		return nil, diags
	}

	paranoiaLevelVal, ok := paranoiaLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paranoia_level expected to be basetypes.Int64Value, was: %T`, paranoiaLevelAttribute))
	}

	requestHeaderNameAttribute, ok := attributes["request_header_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_name is missing from object`)

		return nil, diags
	}

	requestHeaderNameVal, ok := requestHeaderNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_name expected to be basetypes.StringValue, was: %T`, requestHeaderNameAttribute))
	}

	requestHeaderRatelimitCooldownAttribute, ok := attributes["request_header_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_cooldown is missing from object`)

		return nil, diags
	}

	requestHeaderRatelimitCooldownVal, ok := requestHeaderRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, requestHeaderRatelimitCooldownAttribute))
	}

	requestHeaderRatelimitModeAttribute, ok := attributes["request_header_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_mode is missing from object`)

		return nil, diags
	}

	requestHeaderRatelimitModeVal, ok := requestHeaderRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_mode expected to be basetypes.StringValue, was: %T`, requestHeaderRatelimitModeAttribute))
	}

	requestHeaderRatelimitRpsAttribute, ok := attributes["request_header_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_rps is missing from object`)

		return nil, diags
	}

	requestHeaderRatelimitRpsVal, ok := requestHeaderRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, requestHeaderRatelimitRpsAttribute))
	}

	thresholdsAttribute, ok := attributes["thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thresholds is missing from object`)

		return nil, diags
	}

	thresholdsVal, ok := thresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thresholds expected to be basetypes.ListValue, was: %T`, thresholdsAttribute))
	}

	wafRatelimitCooldownAttribute, ok := attributes["waf_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_cooldown is missing from object`)

		return nil, diags
	}

	wafRatelimitCooldownVal, ok := wafRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, wafRatelimitCooldownAttribute))
	}

	wafRatelimitHitsAttribute, ok := attributes["waf_ratelimit_hits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_hits is missing from object`)

		return nil, diags
	}

	wafRatelimitHitsVal, ok := wafRatelimitHitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_hits expected to be basetypes.Int64Value, was: %T`, wafRatelimitHitsAttribute))
	}

	wafRatelimitModeAttribute, ok := attributes["waf_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_mode is missing from object`)

		return nil, diags
	}

	wafRatelimitModeVal, ok := wafRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_mode expected to be basetypes.StringValue, was: %T`, wafRatelimitModeAttribute))
	}

	wafRatelimitRpsAttribute, ok := attributes["waf_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_rps is missing from object`)

		return nil, diags
	}

	wafRatelimitRpsVal, ok := wafRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, wafRatelimitRpsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WafConfigValue{
		AllowIp:                        allowIpVal,
		AllowRules:                     allowRulesVal,
		BlockIp:                        blockIpVal,
		BlockLists:                     blockListsVal,
		BlockReferer:                   blockRefererVal,
		BlockUa:                        blockUaVal,
		Httpbl:                         httpblVal,
		HttpblEnabled:                  httpblEnabledVal,
		IpRatelimitCooldown:            ipRatelimitCooldownVal,
		IpRatelimitMode:                ipRatelimitModeVal,
		IpRatelimitRps:                 ipRatelimitRpsVal,
		Mode:                           modeVal,
		NotifyEmail:                    notifyEmailVal,
		NotifySlack:                    notifySlackVal,
		NotifySlackHitsRpm:             notifySlackHitsRpmVal,
		NotifySlackRpm:                 notifySlackRpmVal,
		ParanoiaLevel:                  paranoiaLevelVal,
		RequestHeaderName:              requestHeaderNameVal,
		RequestHeaderRatelimitCooldown: requestHeaderRatelimitCooldownVal,
		RequestHeaderRatelimitMode:     requestHeaderRatelimitModeVal,
		RequestHeaderRatelimitRps:      requestHeaderRatelimitRpsVal,
		Thresholds:                     thresholdsVal,
		WafRatelimitCooldown:           wafRatelimitCooldownVal,
		WafRatelimitHits:               wafRatelimitHitsVal,
		WafRatelimitMode:               wafRatelimitModeVal,
		WafRatelimitRps:                wafRatelimitRpsVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewWafConfigValueNull() WafConfigValue {
	return WafConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewWafConfigValueUnknown() WafConfigValue {
	return WafConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWafConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WafConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WafConfigValue Attribute Value",
				"While creating a WafConfigValue value, a missing attribute value was detected. "+
					"A WafConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WafConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WafConfigValue Attribute Type",
				"While creating a WafConfigValue value, an invalid attribute value was detected. "+
					"A WafConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WafConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WafConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WafConfigValue Attribute Value",
				"While creating a WafConfigValue value, an extra attribute value was detected. "+
					"A WafConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WafConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWafConfigValueUnknown(), diags
	}

	allowIpAttribute, ok := attributes["allow_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ip is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	allowIpVal, ok := allowIpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ip expected to be basetypes.ListValue, was: %T`, allowIpAttribute))
	}

	allowRulesAttribute, ok := attributes["allow_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rules is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	allowRulesVal, ok := allowRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rules expected to be basetypes.ListValue, was: %T`, allowRulesAttribute))
	}

	blockIpAttribute, ok := attributes["block_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_ip is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	blockIpVal, ok := blockIpAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_ip expected to be basetypes.ListValue, was: %T`, blockIpAttribute))
	}

	blockListsAttribute, ok := attributes["block_lists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_lists is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	blockListsVal, ok := blockListsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_lists expected to be basetypes.ObjectValue, was: %T`, blockListsAttribute))
	}

	blockRefererAttribute, ok := attributes["block_referer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_referer is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	blockRefererVal, ok := blockRefererAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_referer expected to be basetypes.ListValue, was: %T`, blockRefererAttribute))
	}

	blockUaAttribute, ok := attributes["block_ua"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_ua is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	blockUaVal, ok := blockUaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_ua expected to be basetypes.ListValue, was: %T`, blockUaAttribute))
	}

	httpblAttribute, ok := attributes["httpbl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	httpblVal, ok := httpblAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl expected to be basetypes.ObjectValue, was: %T`, httpblAttribute))
	}

	httpblEnabledAttribute, ok := attributes["httpbl_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl_enabled is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	httpblEnabledVal, ok := httpblEnabledAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl_enabled expected to be basetypes.MapValue, was: %T`, httpblEnabledAttribute))
	}

	ipRatelimitCooldownAttribute, ok := attributes["ip_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_cooldown is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	ipRatelimitCooldownVal, ok := ipRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, ipRatelimitCooldownAttribute))
	}

	ipRatelimitModeAttribute, ok := attributes["ip_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_mode is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	ipRatelimitModeVal, ok := ipRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_mode expected to be basetypes.StringValue, was: %T`, ipRatelimitModeAttribute))
	}

	ipRatelimitRpsAttribute, ok := attributes["ip_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_ratelimit_rps is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	ipRatelimitRpsVal, ok := ipRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, ipRatelimitRpsAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	notifyEmailAttribute, ok := attributes["notify_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_email is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	notifyEmailVal, ok := notifyEmailAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_email expected to be basetypes.ListValue, was: %T`, notifyEmailAttribute))
	}

	notifySlackAttribute, ok := attributes["notify_slack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	notifySlackVal, ok := notifySlackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack expected to be basetypes.StringValue, was: %T`, notifySlackAttribute))
	}

	notifySlackHitsRpmAttribute, ok := attributes["notify_slack_hits_rpm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack_hits_rpm is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	notifySlackHitsRpmVal, ok := notifySlackHitsRpmAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack_hits_rpm expected to be basetypes.Int64Value, was: %T`, notifySlackHitsRpmAttribute))
	}

	notifySlackRpmAttribute, ok := attributes["notify_slack_rpm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack_rpm is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	notifySlackRpmVal, ok := notifySlackRpmAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack_rpm expected to be basetypes.Int64Value, was: %T`, notifySlackRpmAttribute))
	}

	paranoiaLevelAttribute, ok := attributes["paranoia_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paranoia_level is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	paranoiaLevelVal, ok := paranoiaLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paranoia_level expected to be basetypes.Int64Value, was: %T`, paranoiaLevelAttribute))
	}

	requestHeaderNameAttribute, ok := attributes["request_header_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_name is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	requestHeaderNameVal, ok := requestHeaderNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_name expected to be basetypes.StringValue, was: %T`, requestHeaderNameAttribute))
	}

	requestHeaderRatelimitCooldownAttribute, ok := attributes["request_header_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_cooldown is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	requestHeaderRatelimitCooldownVal, ok := requestHeaderRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, requestHeaderRatelimitCooldownAttribute))
	}

	requestHeaderRatelimitModeAttribute, ok := attributes["request_header_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_mode is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	requestHeaderRatelimitModeVal, ok := requestHeaderRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_mode expected to be basetypes.StringValue, was: %T`, requestHeaderRatelimitModeAttribute))
	}

	requestHeaderRatelimitRpsAttribute, ok := attributes["request_header_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_header_ratelimit_rps is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	requestHeaderRatelimitRpsVal, ok := requestHeaderRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_header_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, requestHeaderRatelimitRpsAttribute))
	}

	thresholdsAttribute, ok := attributes["thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thresholds is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	thresholdsVal, ok := thresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thresholds expected to be basetypes.ListValue, was: %T`, thresholdsAttribute))
	}

	wafRatelimitCooldownAttribute, ok := attributes["waf_ratelimit_cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_cooldown is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	wafRatelimitCooldownVal, ok := wafRatelimitCooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_cooldown expected to be basetypes.Int64Value, was: %T`, wafRatelimitCooldownAttribute))
	}

	wafRatelimitHitsAttribute, ok := attributes["waf_ratelimit_hits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_hits is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	wafRatelimitHitsVal, ok := wafRatelimitHitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_hits expected to be basetypes.Int64Value, was: %T`, wafRatelimitHitsAttribute))
	}

	wafRatelimitModeAttribute, ok := attributes["waf_ratelimit_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_mode is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	wafRatelimitModeVal, ok := wafRatelimitModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_mode expected to be basetypes.StringValue, was: %T`, wafRatelimitModeAttribute))
	}

	wafRatelimitRpsAttribute, ok := attributes["waf_ratelimit_rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`waf_ratelimit_rps is missing from object`)

		return NewWafConfigValueUnknown(), diags
	}

	wafRatelimitRpsVal, ok := wafRatelimitRpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`waf_ratelimit_rps expected to be basetypes.Int64Value, was: %T`, wafRatelimitRpsAttribute))
	}

	if diags.HasError() {
		return NewWafConfigValueUnknown(), diags
	}

	return WafConfigValue{
		AllowIp:                        allowIpVal,
		AllowRules:                     allowRulesVal,
		BlockIp:                        blockIpVal,
		BlockLists:                     blockListsVal,
		BlockReferer:                   blockRefererVal,
		BlockUa:                        blockUaVal,
		Httpbl:                         httpblVal,
		HttpblEnabled:                  httpblEnabledVal,
		IpRatelimitCooldown:            ipRatelimitCooldownVal,
		IpRatelimitMode:                ipRatelimitModeVal,
		IpRatelimitRps:                 ipRatelimitRpsVal,
		Mode:                           modeVal,
		NotifyEmail:                    notifyEmailVal,
		NotifySlack:                    notifySlackVal,
		NotifySlackHitsRpm:             notifySlackHitsRpmVal,
		NotifySlackRpm:                 notifySlackRpmVal,
		ParanoiaLevel:                  paranoiaLevelVal,
		RequestHeaderName:              requestHeaderNameVal,
		RequestHeaderRatelimitCooldown: requestHeaderRatelimitCooldownVal,
		RequestHeaderRatelimitMode:     requestHeaderRatelimitModeVal,
		RequestHeaderRatelimitRps:      requestHeaderRatelimitRpsVal,
		Thresholds:                     thresholdsVal,
		WafRatelimitCooldown:           wafRatelimitCooldownVal,
		WafRatelimitHits:               wafRatelimitHitsVal,
		WafRatelimitMode:               wafRatelimitModeVal,
		WafRatelimitRps:                wafRatelimitRpsVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewWafConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WafConfigValue {
	object, diags := NewWafConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWafConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WafConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWafConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWafConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWafConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWafConfigValueMust(WafConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WafConfigType) ValueType(ctx context.Context) attr.Value {
	return WafConfigValue{}
}

var _ basetypes.ObjectValuable = WafConfigValue{}

type WafConfigValue struct {
	AllowIp                        basetypes.ListValue   `tfsdk:"allow_ip"`
	AllowRules                     basetypes.ListValue   `tfsdk:"allow_rules"`
	BlockIp                        basetypes.ListValue   `tfsdk:"block_ip"`
	BlockLists                     basetypes.ObjectValue `tfsdk:"block_lists"`
	BlockReferer                   basetypes.ListValue   `tfsdk:"block_referer"`
	BlockUa                        basetypes.ListValue   `tfsdk:"block_ua"`
	Httpbl                         basetypes.ObjectValue `tfsdk:"httpbl"`
	HttpblEnabled                  basetypes.MapValue    `tfsdk:"httpbl_enabled"`
	IpRatelimitCooldown            basetypes.Int64Value  `tfsdk:"ip_ratelimit_cooldown"`
	IpRatelimitMode                basetypes.StringValue `tfsdk:"ip_ratelimit_mode"`
	IpRatelimitRps                 basetypes.Int64Value  `tfsdk:"ip_ratelimit_rps"`
	Mode                           basetypes.StringValue `tfsdk:"mode"`
	NotifyEmail                    basetypes.ListValue   `tfsdk:"notify_email"`
	NotifySlack                    basetypes.StringValue `tfsdk:"notify_slack"`
	NotifySlackHitsRpm             basetypes.Int64Value  `tfsdk:"notify_slack_hits_rpm"`
	NotifySlackRpm                 basetypes.Int64Value  `tfsdk:"notify_slack_rpm"`
	ParanoiaLevel                  basetypes.Int64Value  `tfsdk:"paranoia_level"`
	RequestHeaderName              basetypes.StringValue `tfsdk:"request_header_name"`
	RequestHeaderRatelimitCooldown basetypes.Int64Value  `tfsdk:"request_header_ratelimit_cooldown"`
	RequestHeaderRatelimitMode     basetypes.StringValue `tfsdk:"request_header_ratelimit_mode"`
	RequestHeaderRatelimitRps      basetypes.Int64Value  `tfsdk:"request_header_ratelimit_rps"`
	Thresholds                     basetypes.ListValue   `tfsdk:"thresholds"`
	WafRatelimitCooldown           basetypes.Int64Value  `tfsdk:"waf_ratelimit_cooldown"`
	WafRatelimitHits               basetypes.Int64Value  `tfsdk:"waf_ratelimit_hits"`
	WafRatelimitMode               basetypes.StringValue `tfsdk:"waf_ratelimit_mode"`
	WafRatelimitRps                basetypes.Int64Value  `tfsdk:"waf_ratelimit_rps"`
	state                          attr.ValueState
}

func (v WafConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 26)

	var val tftypes.Value
	var err error

	attrTypes["allow_ip"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["allow_rules"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["block_ip"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["block_lists"] = basetypes.ObjectType{
		AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["block_referer"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["block_ua"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["httpbl"] = basetypes.ObjectType{
		AttrTypes: HttpblValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["httpbl_enabled"] = basetypes.MapType{
		ElemType: types.BoolType,
	}.TerraformType(ctx)
	attrTypes["ip_ratelimit_cooldown"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ip_ratelimit_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_ratelimit_rps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_email"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["notify_slack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_slack_hits_rpm"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["notify_slack_rpm"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["paranoia_level"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["request_header_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["request_header_ratelimit_cooldown"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["request_header_ratelimit_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["request_header_ratelimit_rps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["thresholds"] = basetypes.ListType{
		ElemType: ThresholdsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["waf_ratelimit_cooldown"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["waf_ratelimit_hits"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["waf_ratelimit_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["waf_ratelimit_rps"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 26)

		val, err = v.AllowIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_ip"] = val

		val, err = v.AllowRules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rules"] = val

		val, err = v.BlockIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_ip"] = val

		val, err = v.BlockLists.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_lists"] = val

		val, err = v.BlockReferer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_referer"] = val

		val, err = v.BlockUa.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_ua"] = val

		val, err = v.Httpbl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["httpbl"] = val

		val, err = v.HttpblEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["httpbl_enabled"] = val

		val, err = v.IpRatelimitCooldown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_ratelimit_cooldown"] = val

		val, err = v.IpRatelimitMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_ratelimit_mode"] = val

		val, err = v.IpRatelimitRps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_ratelimit_rps"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.NotifyEmail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_email"] = val

		val, err = v.NotifySlack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_slack"] = val

		val, err = v.NotifySlackHitsRpm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_slack_hits_rpm"] = val

		val, err = v.NotifySlackRpm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_slack_rpm"] = val

		val, err = v.ParanoiaLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paranoia_level"] = val

		val, err = v.RequestHeaderName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_header_name"] = val

		val, err = v.RequestHeaderRatelimitCooldown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_header_ratelimit_cooldown"] = val

		val, err = v.RequestHeaderRatelimitMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_header_ratelimit_mode"] = val

		val, err = v.RequestHeaderRatelimitRps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_header_ratelimit_rps"] = val

		val, err = v.Thresholds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["thresholds"] = val

		val, err = v.WafRatelimitCooldown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_ratelimit_cooldown"] = val

		val, err = v.WafRatelimitHits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_ratelimit_hits"] = val

		val, err = v.WafRatelimitMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_ratelimit_mode"] = val

		val, err = v.WafRatelimitRps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["waf_ratelimit_rps"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WafConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WafConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WafConfigValue) String() string {
	return "WafConfigValue"
}

func (v WafConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var blockLists basetypes.ObjectValue

	if v.BlockLists.IsNull() {
		blockLists = types.ObjectNull(
			BlockListsValue{}.AttributeTypes(ctx),
		)
	}

	if v.BlockLists.IsUnknown() {
		blockLists = types.ObjectUnknown(
			BlockListsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BlockLists.IsNull() && !v.BlockLists.IsUnknown() {
		blockLists = types.ObjectValueMust(
			BlockListsValue{}.AttributeTypes(ctx),
			v.BlockLists.Attributes(),
		)
	}

	var httpbl basetypes.ObjectValue

	if v.Httpbl.IsNull() {
		httpbl = types.ObjectNull(
			HttpblValue{}.AttributeTypes(ctx),
		)
	}

	if v.Httpbl.IsUnknown() {
		httpbl = types.ObjectUnknown(
			HttpblValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Httpbl.IsNull() && !v.Httpbl.IsUnknown() {
		httpbl = types.ObjectValueMust(
			HttpblValue{}.AttributeTypes(ctx),
			v.Httpbl.Attributes(),
		)
	}

	thresholds := types.ListValueMust(
		ThresholdsType{
			basetypes.ObjectType{
				AttrTypes: ThresholdsValue{}.AttributeTypes(ctx),
			},
		},
		v.Thresholds.Elements(),
	)

	if v.Thresholds.IsNull() {
		thresholds = types.ListNull(
			ThresholdsType{
				basetypes.ObjectType{
					AttrTypes: ThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Thresholds.IsUnknown() {
		thresholds = types.ListUnknown(
			ThresholdsType{
				basetypes.ObjectType{
					AttrTypes: ThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	allowIpVal, d := types.ListValue(types.StringType, v.AllowIp.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	allowRulesVal, d := types.ListValue(types.StringType, v.AllowRules.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	blockIpVal, d := types.ListValue(types.StringType, v.BlockIp.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	blockRefererVal, d := types.ListValue(types.StringType, v.BlockReferer.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	blockUaVal, d := types.ListValue(types.StringType, v.BlockUa.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	httpblEnabledVal, d := types.MapValue(types.BoolType, v.HttpblEnabled.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	notifyEmailVal, d := types.ListValue(types.StringType, v.NotifyEmail.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"allow_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allow_rules": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ip": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_lists": basetypes.ObjectType{
				AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
			},
			"block_referer": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_ua": basetypes.ListType{
				ElemType: types.StringType,
			},
			"httpbl": basetypes.ObjectType{
				AttrTypes: HttpblValue{}.AttributeTypes(ctx),
			},
			"httpbl_enabled": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"ip_ratelimit_cooldown": basetypes.Int64Type{},
			"ip_ratelimit_mode":     basetypes.StringType{},
			"ip_ratelimit_rps":      basetypes.Int64Type{},
			"mode":                  basetypes.StringType{},
			"notify_email": basetypes.ListType{
				ElemType: types.StringType,
			},
			"notify_slack":                      basetypes.StringType{},
			"notify_slack_hits_rpm":             basetypes.Int64Type{},
			"notify_slack_rpm":                  basetypes.Int64Type{},
			"paranoia_level":                    basetypes.Int64Type{},
			"request_header_name":               basetypes.StringType{},
			"request_header_ratelimit_cooldown": basetypes.Int64Type{},
			"request_header_ratelimit_mode":     basetypes.StringType{},
			"request_header_ratelimit_rps":      basetypes.Int64Type{},
			"thresholds": basetypes.ListType{
				ElemType: ThresholdsValue{}.Type(ctx),
			},
			"waf_ratelimit_cooldown": basetypes.Int64Type{},
			"waf_ratelimit_hits":     basetypes.Int64Type{},
			"waf_ratelimit_mode":     basetypes.StringType{},
			"waf_ratelimit_rps":      basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"allow_ip":                          allowIpVal,
			"allow_rules":                       allowRulesVal,
			"block_ip":                          blockIpVal,
			"block_lists":                       blockLists,
			"block_referer":                     blockRefererVal,
			"block_ua":                          blockUaVal,
			"httpbl":                            httpbl,
			"httpbl_enabled":                    httpblEnabledVal,
			"ip_ratelimit_cooldown":             v.IpRatelimitCooldown,
			"ip_ratelimit_mode":                 v.IpRatelimitMode,
			"ip_ratelimit_rps":                  v.IpRatelimitRps,
			"mode":                              v.Mode,
			"notify_email":                      notifyEmailVal,
			"notify_slack":                      v.NotifySlack,
			"notify_slack_hits_rpm":             v.NotifySlackHitsRpm,
			"notify_slack_rpm":                  v.NotifySlackRpm,
			"paranoia_level":                    v.ParanoiaLevel,
			"request_header_name":               v.RequestHeaderName,
			"request_header_ratelimit_cooldown": v.RequestHeaderRatelimitCooldown,
			"request_header_ratelimit_mode":     v.RequestHeaderRatelimitMode,
			"request_header_ratelimit_rps":      v.RequestHeaderRatelimitRps,
			"thresholds":                        thresholds,
			"waf_ratelimit_cooldown":            v.WafRatelimitCooldown,
			"waf_ratelimit_hits":                v.WafRatelimitHits,
			"waf_ratelimit_mode":                v.WafRatelimitMode,
			"waf_ratelimit_rps":                 v.WafRatelimitRps,
		})

	return objVal, diags
}

func (v WafConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(WafConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowIp.Equal(other.AllowIp) {
		return false
	}

	if !v.AllowRules.Equal(other.AllowRules) {
		return false
	}

	if !v.BlockIp.Equal(other.BlockIp) {
		return false
	}

	if !v.BlockLists.Equal(other.BlockLists) {
		return false
	}

	if !v.BlockReferer.Equal(other.BlockReferer) {
		return false
	}

	if !v.BlockUa.Equal(other.BlockUa) {
		return false
	}

	if !v.Httpbl.Equal(other.Httpbl) {
		return false
	}

	if !v.HttpblEnabled.Equal(other.HttpblEnabled) {
		return false
	}

	if !v.IpRatelimitCooldown.Equal(other.IpRatelimitCooldown) {
		return false
	}

	if !v.IpRatelimitMode.Equal(other.IpRatelimitMode) {
		return false
	}

	if !v.IpRatelimitRps.Equal(other.IpRatelimitRps) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.NotifyEmail.Equal(other.NotifyEmail) {
		return false
	}

	if !v.NotifySlack.Equal(other.NotifySlack) {
		return false
	}

	if !v.NotifySlackHitsRpm.Equal(other.NotifySlackHitsRpm) {
		return false
	}

	if !v.NotifySlackRpm.Equal(other.NotifySlackRpm) {
		return false
	}

	if !v.ParanoiaLevel.Equal(other.ParanoiaLevel) {
		return false
	}

	if !v.RequestHeaderName.Equal(other.RequestHeaderName) {
		return false
	}

	if !v.RequestHeaderRatelimitCooldown.Equal(other.RequestHeaderRatelimitCooldown) {
		return false
	}

	if !v.RequestHeaderRatelimitMode.Equal(other.RequestHeaderRatelimitMode) {
		return false
	}

	if !v.RequestHeaderRatelimitRps.Equal(other.RequestHeaderRatelimitRps) {
		return false
	}

	if !v.Thresholds.Equal(other.Thresholds) {
		return false
	}

	if !v.WafRatelimitCooldown.Equal(other.WafRatelimitCooldown) {
		return false
	}

	if !v.WafRatelimitHits.Equal(other.WafRatelimitHits) {
		return false
	}

	if !v.WafRatelimitMode.Equal(other.WafRatelimitMode) {
		return false
	}

	if !v.WafRatelimitRps.Equal(other.WafRatelimitRps) {
		return false
	}

	return true
}

func (v WafConfigValue) Type(ctx context.Context) attr.Type {
	return WafConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WafConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_ip": basetypes.ListType{
			ElemType: types.StringType,
		},
		"allow_rules": basetypes.ListType{
			ElemType: types.StringType,
		},
		"block_ip": basetypes.ListType{
			ElemType: types.StringType,
		},
		"block_lists": basetypes.ObjectType{
			AttrTypes: BlockListsValue{}.AttributeTypes(ctx),
		},
		"block_referer": basetypes.ListType{
			ElemType: types.StringType,
		},
		"block_ua": basetypes.ListType{
			ElemType: types.StringType,
		},
		"httpbl": basetypes.ObjectType{
			AttrTypes: HttpblValue{}.AttributeTypes(ctx),
		},
		"httpbl_enabled": basetypes.MapType{
			ElemType: types.BoolType,
		},
		"ip_ratelimit_cooldown": basetypes.Int64Type{},
		"ip_ratelimit_mode":     basetypes.StringType{},
		"ip_ratelimit_rps":      basetypes.Int64Type{},
		"mode":                  basetypes.StringType{},
		"notify_email": basetypes.ListType{
			ElemType: types.StringType,
		},
		"notify_slack":                      basetypes.StringType{},
		"notify_slack_hits_rpm":             basetypes.Int64Type{},
		"notify_slack_rpm":                  basetypes.Int64Type{},
		"paranoia_level":                    basetypes.Int64Type{},
		"request_header_name":               basetypes.StringType{},
		"request_header_ratelimit_cooldown": basetypes.Int64Type{},
		"request_header_ratelimit_mode":     basetypes.StringType{},
		"request_header_ratelimit_rps":      basetypes.Int64Type{},
		"thresholds": basetypes.ListType{
			ElemType: ThresholdsValue{}.Type(ctx),
		},
		"waf_ratelimit_cooldown": basetypes.Int64Type{},
		"waf_ratelimit_hits":     basetypes.Int64Type{},
		"waf_ratelimit_mode":     basetypes.StringType{},
		"waf_ratelimit_rps":      basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BlockListsType{}

type BlockListsType struct {
	basetypes.ObjectType
}

func (t BlockListsType) Equal(o attr.Type) bool {
	other, ok := o.(BlockListsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BlockListsType) String() string {
	return "BlockListsType"
}

func (t BlockListsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aiAttribute, ok := attributes["ai"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ai is missing from object`)

		return nil, diags
	}

	aiVal, ok := aiAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ai expected to be basetypes.BoolValue, was: %T`, aiAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.BoolValue, was: %T`, ipAttribute))
	}

	refererAttribute, ok := attributes["referer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`referer is missing from object`)

		return nil, diags
	}

	refererVal, ok := refererAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`referer expected to be basetypes.BoolValue, was: %T`, refererAttribute))
	}

	userAgentAttribute, ok := attributes["user_agent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_agent is missing from object`)

		return nil, diags
	}

	userAgentVal, ok := userAgentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_agent expected to be basetypes.BoolValue, was: %T`, userAgentAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BlockListsValue{
		Ai:        aiVal,
		Ip:        ipVal,
		Referer:   refererVal,
		UserAgent: userAgentVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewBlockListsValueNull() BlockListsValue {
	return BlockListsValue{
		state: attr.ValueStateNull,
	}
}

func NewBlockListsValueUnknown() BlockListsValue {
	return BlockListsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBlockListsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BlockListsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BlockListsValue Attribute Value",
				"While creating a BlockListsValue value, a missing attribute value was detected. "+
					"A BlockListsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlockListsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BlockListsValue Attribute Type",
				"While creating a BlockListsValue value, an invalid attribute value was detected. "+
					"A BlockListsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlockListsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BlockListsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BlockListsValue Attribute Value",
				"While creating a BlockListsValue value, an extra attribute value was detected. "+
					"A BlockListsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BlockListsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBlockListsValueUnknown(), diags
	}

	aiAttribute, ok := attributes["ai"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ai is missing from object`)

		return NewBlockListsValueUnknown(), diags
	}

	aiVal, ok := aiAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ai expected to be basetypes.BoolValue, was: %T`, aiAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewBlockListsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.BoolValue, was: %T`, ipAttribute))
	}

	refererAttribute, ok := attributes["referer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`referer is missing from object`)

		return NewBlockListsValueUnknown(), diags
	}

	refererVal, ok := refererAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`referer expected to be basetypes.BoolValue, was: %T`, refererAttribute))
	}

	userAgentAttribute, ok := attributes["user_agent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_agent is missing from object`)

		return NewBlockListsValueUnknown(), diags
	}

	userAgentVal, ok := userAgentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_agent expected to be basetypes.BoolValue, was: %T`, userAgentAttribute))
	}

	if diags.HasError() {
		return NewBlockListsValueUnknown(), diags
	}

	return BlockListsValue{
		Ai:        aiVal,
		Ip:        ipVal,
		Referer:   refererVal,
		UserAgent: userAgentVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewBlockListsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BlockListsValue {
	object, diags := NewBlockListsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBlockListsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BlockListsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBlockListsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBlockListsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBlockListsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBlockListsValueMust(BlockListsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BlockListsType) ValueType(ctx context.Context) attr.Value {
	return BlockListsValue{}
}

var _ basetypes.ObjectValuable = BlockListsValue{}

type BlockListsValue struct {
	Ai        basetypes.BoolValue `tfsdk:"ai"`
	Ip        basetypes.BoolValue `tfsdk:"ip"`
	Referer   basetypes.BoolValue `tfsdk:"referer"`
	UserAgent basetypes.BoolValue `tfsdk:"user_agent"`
	state     attr.ValueState
}

func (v BlockListsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ai"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["referer"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["user_agent"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Ai.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ai"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Referer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["referer"] = val

		val, err = v.UserAgent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_agent"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BlockListsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BlockListsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BlockListsValue) String() string {
	return "BlockListsValue"
}

func (v BlockListsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"ai":         basetypes.BoolType{},
			"ip":         basetypes.BoolType{},
			"referer":    basetypes.BoolType{},
			"user_agent": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"ai":         v.Ai,
			"ip":         v.Ip,
			"referer":    v.Referer,
			"user_agent": v.UserAgent,
		})

	return objVal, diags
}

func (v BlockListsValue) Equal(o attr.Value) bool {
	other, ok := o.(BlockListsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ai.Equal(other.Ai) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Referer.Equal(other.Referer) {
		return false
	}

	if !v.UserAgent.Equal(other.UserAgent) {
		return false
	}

	return true
}

func (v BlockListsValue) Type(ctx context.Context) attr.Type {
	return BlockListsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BlockListsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ai":         basetypes.BoolType{},
		"ip":         basetypes.BoolType{},
		"referer":    basetypes.BoolType{},
		"user_agent": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = HttpblType{}

type HttpblType struct {
	basetypes.ObjectType
}

func (t HttpblType) Equal(o attr.Type) bool {
	other, ok := o.(HttpblType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HttpblType) String() string {
	return "HttpblType"
}

func (t HttpblType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return nil, diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	blockHarvesterAttribute, ok := attributes["block_harvester"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_harvester is missing from object`)

		return nil, diags
	}

	blockHarvesterVal, ok := blockHarvesterAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_harvester expected to be basetypes.BoolValue, was: %T`, blockHarvesterAttribute))
	}

	blockSearchEngineAttribute, ok := attributes["block_search_engine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_search_engine is missing from object`)

		return nil, diags
	}

	blockSearchEngineVal, ok := blockSearchEngineAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_search_engine expected to be basetypes.BoolValue, was: %T`, blockSearchEngineAttribute))
	}

	blockSpamAttribute, ok := attributes["block_spam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_spam is missing from object`)

		return nil, diags
	}

	blockSpamVal, ok := blockSpamAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_spam expected to be basetypes.BoolValue, was: %T`, blockSpamAttribute))
	}

	blockSuspiciousAttribute, ok := attributes["block_suspicious"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_suspicious is missing from object`)

		return nil, diags
	}

	blockSuspiciousVal, ok := blockSuspiciousAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_suspicious expected to be basetypes.BoolValue, was: %T`, blockSuspiciousAttribute))
	}

	httpblEnabledAttribute, ok := attributes["httpbl_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl_enabled is missing from object`)

		return nil, diags
	}

	httpblEnabledVal, ok := httpblEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl_enabled expected to be basetypes.BoolValue, was: %T`, httpblEnabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HttpblValue{
		ApiKey:            apiKeyVal,
		BlockHarvester:    blockHarvesterVal,
		BlockSearchEngine: blockSearchEngineVal,
		BlockSpam:         blockSpamVal,
		BlockSuspicious:   blockSuspiciousVal,
		HttpblEnabled:     httpblEnabledVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewHttpblValueNull() HttpblValue {
	return HttpblValue{
		state: attr.ValueStateNull,
	}
}

func NewHttpblValueUnknown() HttpblValue {
	return HttpblValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHttpblValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HttpblValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HttpblValue Attribute Value",
				"While creating a HttpblValue value, a missing attribute value was detected. "+
					"A HttpblValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HttpblValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HttpblValue Attribute Type",
				"While creating a HttpblValue value, an invalid attribute value was detected. "+
					"A HttpblValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HttpblValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HttpblValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HttpblValue Attribute Value",
				"While creating a HttpblValue value, an extra attribute value was detected. "+
					"A HttpblValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HttpblValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHttpblValueUnknown(), diags
	}

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	blockHarvesterAttribute, ok := attributes["block_harvester"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_harvester is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	blockHarvesterVal, ok := blockHarvesterAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_harvester expected to be basetypes.BoolValue, was: %T`, blockHarvesterAttribute))
	}

	blockSearchEngineAttribute, ok := attributes["block_search_engine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_search_engine is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	blockSearchEngineVal, ok := blockSearchEngineAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_search_engine expected to be basetypes.BoolValue, was: %T`, blockSearchEngineAttribute))
	}

	blockSpamAttribute, ok := attributes["block_spam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_spam is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	blockSpamVal, ok := blockSpamAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_spam expected to be basetypes.BoolValue, was: %T`, blockSpamAttribute))
	}

	blockSuspiciousAttribute, ok := attributes["block_suspicious"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_suspicious is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	blockSuspiciousVal, ok := blockSuspiciousAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_suspicious expected to be basetypes.BoolValue, was: %T`, blockSuspiciousAttribute))
	}

	httpblEnabledAttribute, ok := attributes["httpbl_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`httpbl_enabled is missing from object`)

		return NewHttpblValueUnknown(), diags
	}

	httpblEnabledVal, ok := httpblEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`httpbl_enabled expected to be basetypes.BoolValue, was: %T`, httpblEnabledAttribute))
	}

	if diags.HasError() {
		return NewHttpblValueUnknown(), diags
	}

	return HttpblValue{
		ApiKey:            apiKeyVal,
		BlockHarvester:    blockHarvesterVal,
		BlockSearchEngine: blockSearchEngineVal,
		BlockSpam:         blockSpamVal,
		BlockSuspicious:   blockSuspiciousVal,
		HttpblEnabled:     httpblEnabledVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewHttpblValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HttpblValue {
	object, diags := NewHttpblValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHttpblValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HttpblType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHttpblValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHttpblValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHttpblValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHttpblValueMust(HttpblValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HttpblType) ValueType(ctx context.Context) attr.Value {
	return HttpblValue{}
}

var _ basetypes.ObjectValuable = HttpblValue{}

type HttpblValue struct {
	ApiKey            basetypes.StringValue `tfsdk:"api_key"`
	BlockHarvester    basetypes.BoolValue   `tfsdk:"block_harvester"`
	BlockSearchEngine basetypes.BoolValue   `tfsdk:"block_search_engine"`
	BlockSpam         basetypes.BoolValue   `tfsdk:"block_spam"`
	BlockSuspicious   basetypes.BoolValue   `tfsdk:"block_suspicious"`
	HttpblEnabled     basetypes.BoolValue   `tfsdk:"httpbl_enabled"`
	state             attr.ValueState
}

func (v HttpblValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["block_harvester"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["block_search_engine"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["block_spam"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["block_suspicious"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["httpbl_enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.ApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_key"] = val

		val, err = v.BlockHarvester.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_harvester"] = val

		val, err = v.BlockSearchEngine.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_search_engine"] = val

		val, err = v.BlockSpam.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_spam"] = val

		val, err = v.BlockSuspicious.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_suspicious"] = val

		val, err = v.HttpblEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["httpbl_enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HttpblValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HttpblValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HttpblValue) String() string {
	return "HttpblValue"
}

func (v HttpblValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"api_key":             basetypes.StringType{},
			"block_harvester":     basetypes.BoolType{},
			"block_search_engine": basetypes.BoolType{},
			"block_spam":          basetypes.BoolType{},
			"block_suspicious":    basetypes.BoolType{},
			"httpbl_enabled":      basetypes.BoolType{},
		},
		map[string]attr.Value{
			"api_key":             v.ApiKey,
			"block_harvester":     v.BlockHarvester,
			"block_search_engine": v.BlockSearchEngine,
			"block_spam":          v.BlockSpam,
			"block_suspicious":    v.BlockSuspicious,
			"httpbl_enabled":      v.HttpblEnabled,
		})

	return objVal, diags
}

func (v HttpblValue) Equal(o attr.Value) bool {
	other, ok := o.(HttpblValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiKey.Equal(other.ApiKey) {
		return false
	}

	if !v.BlockHarvester.Equal(other.BlockHarvester) {
		return false
	}

	if !v.BlockSearchEngine.Equal(other.BlockSearchEngine) {
		return false
	}

	if !v.BlockSpam.Equal(other.BlockSpam) {
		return false
	}

	if !v.BlockSuspicious.Equal(other.BlockSuspicious) {
		return false
	}

	if !v.HttpblEnabled.Equal(other.HttpblEnabled) {
		return false
	}

	return true
}

func (v HttpblValue) Type(ctx context.Context) attr.Type {
	return HttpblType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HttpblValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_key":             basetypes.StringType{},
		"block_harvester":     basetypes.BoolType{},
		"block_search_engine": basetypes.BoolType{},
		"block_spam":          basetypes.BoolType{},
		"block_suspicious":    basetypes.BoolType{},
		"httpbl_enabled":      basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ThresholdsType{}

type ThresholdsType struct {
	basetypes.ObjectType
}

func (t ThresholdsType) Equal(o attr.Type) bool {
	other, ok := o.(ThresholdsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ThresholdsType) String() string {
	return "ThresholdsType"
}

func (t ThresholdsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cooldownAttribute, ok := attributes["cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown is missing from object`)

		return nil, diags
	}

	cooldownVal, ok := cooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown expected to be basetypes.Int64Value, was: %T`, cooldownAttribute))
	}

	hitsAttribute, ok := attributes["hits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hits is missing from object`)

		return nil, diags
	}

	hitsVal, ok := hitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hits expected to be basetypes.Int64Value, was: %T`, hitsAttribute))
	}

	minutesAttribute, ok := attributes["minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minutes is missing from object`)

		return nil, diags
	}

	minutesVal, ok := minutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minutes expected to be basetypes.Int64Value, was: %T`, minutesAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	notifySlackAttribute, ok := attributes["notify_slack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack is missing from object`)

		return nil, diags
	}

	notifySlackVal, ok := notifySlackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack expected to be basetypes.StringValue, was: %T`, notifySlackAttribute))
	}

	rpsAttribute, ok := attributes["rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rps is missing from object`)

		return nil, diags
	}

	rpsVal, ok := rpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rps expected to be basetypes.Int64Value, was: %T`, rpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ThresholdsValue{
		Cooldown:       cooldownVal,
		Hits:           hitsVal,
		Minutes:        minutesVal,
		Mode:           modeVal,
		NotifySlack:    notifySlackVal,
		Rps:            rpsVal,
		ThresholdsType: typeVal,
		Value:          valueVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewThresholdsValueNull() ThresholdsValue {
	return ThresholdsValue{
		state: attr.ValueStateNull,
	}
}

func NewThresholdsValueUnknown() ThresholdsValue {
	return ThresholdsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewThresholdsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ThresholdsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ThresholdsValue Attribute Value",
				"While creating a ThresholdsValue value, a missing attribute value was detected. "+
					"A ThresholdsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ThresholdsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ThresholdsValue Attribute Type",
				"While creating a ThresholdsValue value, an invalid attribute value was detected. "+
					"A ThresholdsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ThresholdsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ThresholdsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ThresholdsValue Attribute Value",
				"While creating a ThresholdsValue value, an extra attribute value was detected. "+
					"A ThresholdsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ThresholdsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewThresholdsValueUnknown(), diags
	}

	cooldownAttribute, ok := attributes["cooldown"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	cooldownVal, ok := cooldownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown expected to be basetypes.Int64Value, was: %T`, cooldownAttribute))
	}

	hitsAttribute, ok := attributes["hits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hits is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	hitsVal, ok := hitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hits expected to be basetypes.Int64Value, was: %T`, hitsAttribute))
	}

	minutesAttribute, ok := attributes["minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minutes is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	minutesVal, ok := minutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minutes expected to be basetypes.Int64Value, was: %T`, minutesAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	notifySlackAttribute, ok := attributes["notify_slack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_slack is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	notifySlackVal, ok := notifySlackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_slack expected to be basetypes.StringValue, was: %T`, notifySlackAttribute))
	}

	rpsAttribute, ok := attributes["rps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rps is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	rpsVal, ok := rpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rps expected to be basetypes.Int64Value, was: %T`, rpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewThresholdsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewThresholdsValueUnknown(), diags
	}

	return ThresholdsValue{
		Cooldown:       cooldownVal,
		Hits:           hitsVal,
		Minutes:        minutesVal,
		Mode:           modeVal,
		NotifySlack:    notifySlackVal,
		Rps:            rpsVal,
		ThresholdsType: typeVal,
		Value:          valueVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewThresholdsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ThresholdsValue {
	object, diags := NewThresholdsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewThresholdsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ThresholdsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewThresholdsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewThresholdsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewThresholdsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewThresholdsValueMust(ThresholdsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ThresholdsType) ValueType(ctx context.Context) attr.Value {
	return ThresholdsValue{}
}

var _ basetypes.ObjectValuable = ThresholdsValue{}

type ThresholdsValue struct {
	Cooldown       basetypes.Int64Value  `tfsdk:"cooldown"`
	Hits           basetypes.Int64Value  `tfsdk:"hits"`
	Minutes        basetypes.Int64Value  `tfsdk:"minutes"`
	Mode           basetypes.StringValue `tfsdk:"mode"`
	NotifySlack    basetypes.StringValue `tfsdk:"notify_slack"`
	Rps            basetypes.Int64Value  `tfsdk:"rps"`
	ThresholdsType basetypes.StringValue `tfsdk:"type"`
	Value          basetypes.StringValue `tfsdk:"value"`
	state          attr.ValueState
}

func (v ThresholdsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cooldown"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hits"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minutes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_slack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Cooldown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cooldown"] = val

		val, err = v.Hits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hits"] = val

		val, err = v.Minutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minutes"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.NotifySlack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_slack"] = val

		val, err = v.Rps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rps"] = val

		val, err = v.ThresholdsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ThresholdsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ThresholdsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ThresholdsValue) String() string {
	return "ThresholdsValue"
}

func (v ThresholdsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cooldown":     basetypes.Int64Type{},
			"hits":         basetypes.Int64Type{},
			"minutes":      basetypes.Int64Type{},
			"mode":         basetypes.StringType{},
			"notify_slack": basetypes.StringType{},
			"rps":          basetypes.Int64Type{},
			"type":         basetypes.StringType{},
			"value":        basetypes.StringType{},
		},
		map[string]attr.Value{
			"cooldown":     v.Cooldown,
			"hits":         v.Hits,
			"minutes":      v.Minutes,
			"mode":         v.Mode,
			"notify_slack": v.NotifySlack,
			"rps":          v.Rps,
			"type":         v.ThresholdsType,
			"value":        v.Value,
		})

	return objVal, diags
}

func (v ThresholdsValue) Equal(o attr.Value) bool {
	other, ok := o.(ThresholdsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cooldown.Equal(other.Cooldown) {
		return false
	}

	if !v.Hits.Equal(other.Hits) {
		return false
	}

	if !v.Minutes.Equal(other.Minutes) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.NotifySlack.Equal(other.NotifySlack) {
		return false
	}

	if !v.Rps.Equal(other.Rps) {
		return false
	}

	if !v.ThresholdsType.Equal(other.ThresholdsType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ThresholdsValue) Type(ctx context.Context) attr.Type {
	return ThresholdsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ThresholdsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cooldown":     basetypes.Int64Type{},
		"hits":         basetypes.Int64Type{},
		"minutes":      basetypes.Int64Type{},
		"mode":         basetypes.StringType{},
		"notify_slack": basetypes.StringType{},
		"rps":          basetypes.Int64Type{},
		"type":         basetypes.StringType{},
		"value":        basetypes.StringType{},
	}
}
